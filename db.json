{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/cyanstyle/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/js/navigation.js","path":"js/navigation.js","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/css/images/favicon.ico","path":"css/images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/css/images/body.jpg","path":"css/images/body.jpg","modified":1,"renderable":1},{"_id":"themes/cyanstyle/source/css/images/body-real.jpg","path":"css/images/body-real.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/cyanstyle/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1540976730940},{"_id":"themes/cyanstyle/LICENSE","hash":"450b2b897f0a46934264ca6467ee4ee9145e6095","modified":1540976730941},{"_id":"themes/cyanstyle/README.md","hash":"f06606ee40b88d11f7750b1ab93cad39271504d3","modified":1540976730941},{"_id":"themes/cyanstyle/_config.yml","hash":"59b1b0ec9b139119ddd6309a11fb07871fbc1868","modified":1540976730941},{"_id":"themes/cyanstyle/package.json","hash":"0e0b80bc8fabfcf44e363fac08d0d34d4ac983b8","modified":1540976730964},{"_id":"source/_posts/CSS-px.md","hash":"343a6294fdaf8ba18649d98f56cdc8beec1559a2","modified":1540976730930},{"_id":"source/_posts/Chrome-DevTools-重要快捷键-Mac.md","hash":"5485a2227f92f711f057ec77b17ba82c56d355a6","modified":1540976730931},{"_id":"source/_posts/POST和GET.md","hash":"c723f2c0a85e7c2b74faa16c684ca2aa0610353b","modified":1540976730935},{"_id":"source/_posts/css-e7-bb-86-e8-8a-82.md","hash":"b9b6392cdc65fa4c75cbdb6c7fded284fda85017","modified":1540976730935},{"_id":"source/_posts/e5-85-bc-e5-ae-b9-e6-80-a7tips.md","hash":"87668ff43845a4b3e0ab4128a10849807222750c","modified":1540976730936},{"_id":"source/_posts/html5标签辨析.md","hash":"4ddb91857a977bcf09961eaa9eff5914f117408f","modified":1540976730936},{"_id":"source/_posts/jQuery-offset.md","hash":"bc9b780f0ab64d3eaa24ab17406bce86fdb352fd","modified":1540976730936},{"_id":"source/_posts/span换行.md","hash":"5d8a537324c24ee4e82d2bf15eaef6f6db911c00","modified":1540976730937},{"_id":"source/_posts/vue-2-0-changes.md","hash":"93c0ab5132933bf67b9a8a54aaafe9c7ab83297f","modified":1540976730937},{"_id":"source/_posts/vue2-0-e8-b8-a9-e5-9d-91-e4-b9-8b-e6-97-85.md","hash":"5b0f0b36e131545c67ebba34f57e047edf50e757","modified":1540976730938},{"_id":"source/_posts/事件辨析.md","hash":"af7c81bc88b430a9ce57893e81e39de60aa6a162","modified":1540976730938},{"_id":"source/_posts/z-index要点.md","hash":"b15fd7ab1a9ab5d3cef24f83c2f97e1aa5bc804e","modified":1540976730938},{"_id":"source/_posts/前端错误监控.md","hash":"0693b61124f77d5013131842f645c0dc42fb1c73","modified":1540977928985},{"_id":"source/_posts/《你不知道的JavaScript》-上卷-读书笔记.md","hash":"f5535024687387bb20b6c4a82e313d0fa6a9eac4","modified":1540976730938},{"_id":"source/_posts/电子书爬虫.md","hash":"8abc9e4cab39fe01f1ebe0d8efd4c04393ed4435","modified":1540976730939},{"_id":"source/_posts/复盘-fix不同node-modules引起的bug.md","hash":"41d2b01f5f926f8193fdaa294a8d3930f3dbfb23","modified":1540976730939},{"_id":"source/_posts/迁移完成.md","hash":"2a952866b8363199fb793cf71aac4f8620bbeee0","modified":1540976730940},{"_id":"source/sample-page/index.md","hash":"72fec1c1b3c27e3f1c9d4afd84e13031d6e8beaa","modified":1540976730940},{"_id":"themes/cyanstyle/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1540976730960},{"_id":"themes/cyanstyle/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1540976730960},{"_id":"themes/cyanstyle/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1540976730960},{"_id":"themes/cyanstyle/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1540976730962},{"_id":"themes/cyanstyle/layout/layout.ejs","hash":"c6ba9dd8928c46f83e6cb35162505e46de9e1682","modified":1540976730961},{"_id":"themes/cyanstyle/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1540976730962},{"_id":"themes/cyanstyle/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1540976730964},{"_id":"themes/cyanstyle/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1540976730963},{"_id":"themes/cyanstyle/layout/_partial/after-footer.ejs","hash":"d590f1e27fa166d2cd34b059d47c495b7408bca4","modified":1540976730942},{"_id":"themes/cyanstyle/layout/_partial/archive-post.ejs","hash":"663b7c316355ef91634a9bbf7470dcbc14b83f65","modified":1540976730942},{"_id":"themes/cyanstyle/layout/_partial/archive.ejs","hash":"bb0b0b0a729478b0d428fd7d54f37e93d74004ee","modified":1540976730942},{"_id":"themes/cyanstyle/layout/_partial/article.ejs","hash":"ad1a3b893858df2610e2eadf1eae5cf45b2b3c37","modified":1540976730946},{"_id":"themes/cyanstyle/layout/_partial/comment.ejs","hash":"37138f9db54a530dab05d8a409b3921c78fcfc0d","modified":1540976730946},{"_id":"themes/cyanstyle/layout/_partial/footer.ejs","hash":"8f21bffe029f5938d5732dafa333fa94771f3ac0","modified":1540976730950},{"_id":"themes/cyanstyle/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1540976730951},{"_id":"themes/cyanstyle/layout/_partial/head.ejs","hash":"c956f69324c1ef25dd8512a53d0551c0b2b1f0a8","modified":1540976730952},{"_id":"themes/cyanstyle/layout/_partial/header.ejs","hash":"f1732bca4c5e4a11027cbf300497939507436232","modified":1540976730953},{"_id":"themes/cyanstyle/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1540976730953},{"_id":"themes/cyanstyle/layout/_partial/sidebar.ejs","hash":"b9295e2d892df9dffec829859b02281667f85cc1","modified":1540976730958},{"_id":"themes/cyanstyle/layout/_widget/about.ejs","hash":"1b8aa4e9065ac87e314a65b427c5d55a24333e75","modified":1540976730958},{"_id":"themes/cyanstyle/layout/_widget/account.ejs","hash":"df2503ed0225c034fa5d934575a4bdc7924da20f","modified":1540976730958},{"_id":"themes/cyanstyle/layout/_widget/archive.ejs","hash":"3cb67a156855435ddf50fa6082b34d8e21f7c52b","modified":1540976730959},{"_id":"themes/cyanstyle/layout/_widget/category.ejs","hash":"55377d96929eba1d6ece9cc06b07a34323909092","modified":1540976730959},{"_id":"themes/cyanstyle/layout/_widget/recent_posts.ejs","hash":"ac5682bb66c8fc07e1d1011c93f29c617eab9d34","modified":1540976730959},{"_id":"themes/cyanstyle/layout/_widget/search.ejs","hash":"e4afcfb88e97d25e8f5d8850cfb03b602e3c6f1f","modified":1540976730959},{"_id":"themes/cyanstyle/layout/_widget/tag.ejs","hash":"a62e83cb0214016d2ca2a6e21455e601c8a201eb","modified":1540976730959},{"_id":"themes/cyanstyle/layout/_widget/tagcloud.ejs","hash":"ebe3b3d32fce2e9154d333e859f26ed64748327f","modified":1540976730960},{"_id":"themes/cyanstyle/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1540976730968},{"_id":"themes/cyanstyle/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1540976730969},{"_id":"themes/cyanstyle/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1540976730969},{"_id":"themes/cyanstyle/source/css/style.css","hash":"3d96cc35ee33fecb06df65497ee99c322885a936","modified":1540976730968},{"_id":"themes/cyanstyle/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1540976730969},{"_id":"themes/cyanstyle/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1540976730970},{"_id":"themes/cyanstyle/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1540976730970},{"_id":"themes/cyanstyle/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1540976730972},{"_id":"themes/cyanstyle/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1540976730973},{"_id":"themes/cyanstyle/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1540976730973},{"_id":"themes/cyanstyle/source/js/navigation.js","hash":"1149f4a86285fb1cbf08f3748659368410be6892","modified":1540976730974},{"_id":"themes/cyanstyle/source/js/script.js","hash":"dc57599cf47b6a068f6bbc899aad6fda4576b6ae","modified":1540976730975},{"_id":"themes/cyanstyle/source/js/jquery-2.0.3.min.js","hash":"fbf9c77d0c4e3c34a485980c1e5316b6212160c8","modified":1540976730974},{"_id":"themes/cyanstyle/layout/_partial/post/category.ejs","hash":"8e086ae9864d487d6183ac6e16b92fb35a68639b","modified":1540976730954},{"_id":"themes/cyanstyle/layout/_partial/post/date.ejs","hash":"69785676b6f09a028c75170f3f2d1cb143af9be6","modified":1540976730956},{"_id":"themes/cyanstyle/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1540976730956},{"_id":"themes/cyanstyle/layout/_partial/post/nav.ejs","hash":"2a7cfa6b3ab280d93ae0b4ba8ae3da9b04c80682","modified":1540976730957},{"_id":"themes/cyanstyle/layout/_partial/post/tag.ejs","hash":"ae103b5970c77299547f269b54d046bcc8f38251","modified":1540976730957},{"_id":"themes/cyanstyle/layout/_partial/post/title.ejs","hash":"97d01c3ff12453d76edf5af31dfed9859b3efc5b","modified":1540976730957},{"_id":"themes/cyanstyle/source/css/images/favicon.ico","hash":"bfd1a8233f7341ebac7ca6cf5b0eb8f889dffe03","modified":1540976730968},{"_id":"themes/cyanstyle/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1540976730970},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1540976730971},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1540976730971},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1540976730971},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1540976730972},{"_id":"themes/cyanstyle/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1540976730972},{"_id":"themes/cyanstyle/source/css/images/body.jpg","hash":"92743ba769bb7a7de8e93a418ed36c89e60bc639","modified":1540976730967},{"_id":"themes/cyanstyle/source/css/images/body-real.jpg","hash":"2bbdf623a3b3a421c8de56b8f6853180d2cbabe2","modified":1540976730966},{"_id":"public/sample-page/index.html","hash":"5981f72b93d5161eb907a14f616bf16acb42dd98","modified":1540977936911},{"_id":"public/2018/10/31/前端错误监控/index.html","hash":"225819d2deefeb25eca9e4ee13b170016098c843","modified":1540977936911},{"_id":"public/2018/03/19/jQuery-offset/index.html","hash":"38c6156cede2efe445b090ad6a4042b8e23cecf2","modified":1540977936911},{"_id":"public/2018/03/15/Chrome-DevTools-重要快捷键-Mac/index.html","hash":"2fab6980251a469fe4647f894a7cde8f875f08b1","modified":1540977936912},{"_id":"public/2018/03/15/复盘-fix不同node-modules引起的bug/index.html","hash":"0794b1b60c753b396429a6c9204bebaa84f720c0","modified":1540977936912},{"_id":"public/2018/03/15/事件辨析/index.html","hash":"3da98d294f56b912b1e9c2d235c75b31e4548e60","modified":1540977936912},{"_id":"public/2018/03/15/《你不知道的JavaScript》-上卷-读书笔记/index.html","hash":"68471f288b63d5551f81168bc9f4c959e1e8abfe","modified":1540977936912},{"_id":"public/2017/03/03/CSS-px/index.html","hash":"2021fecf61e14c0a3b211c8edfe4d2d19582bc9f","modified":1540977936912},{"_id":"public/2017/02/21/POST和GET/index.html","hash":"f29d28aeb5eae54924557406900847b7387cabd8","modified":1540977936912},{"_id":"public/2017/02/07/z-index要点/index.html","hash":"e0ea307b9c29b4d7e1e798ccd7f703677c9afb52","modified":1540977936912},{"_id":"public/2017/01/27/span换行/index.html","hash":"cd7b54721f63d812cb9fc370e561db1e1380b6f3","modified":1540977936912},{"_id":"public/2016/10/08/html5标签辨析/index.html","hash":"1629fecdce8ea2d13b28c50205234e30428d590e","modified":1540977936912},{"_id":"public/2016/10/07/电子书爬虫/index.html","hash":"81c7416377afe68758e571d23249dc1e1b2d07fd","modified":1540977936912},{"_id":"public/2016/10/07/迁移完成/index.html","hash":"27c7ee04172d8ba96c17991e26231c1ff9f38960","modified":1540977936912},{"_id":"public/2016/09/09/e5-85-bc-e5-ae-b9-e6-80-a7tips/index.html","hash":"9a8d3a6473670a643e9517e3d0f97f76c3787366","modified":1540977936912},{"_id":"public/2016/08/22/vue2-0-e8-b8-a9-e5-9d-91-e4-b9-8b-e6-97-85/index.html","hash":"a428884f99df6b2336f8ff8a1c77bb7c0517f045","modified":1540977936913},{"_id":"public/2016/08/22/css-e7-bb-86-e8-8a-82/index.html","hash":"81bce9e1b763dc813c2825495ae1c62bbb588a3f","modified":1540977936913},{"_id":"public/2016/08/22/vue-2-0-changes/index.html","hash":"1691d56083edcc5f551c2ef63b5f1dc300abd969","modified":1540977936913},{"_id":"public/categories/css/index.html","hash":"a77b95ad24aeb3b56b0d35412a46abc10e87fc04","modified":1540977936913},{"_id":"public/categories/兼容性/index.html","hash":"eb192c6761582c96c6678271f3ae48f404f75a14","modified":1540977936913},{"_id":"public/categories/vue/index.html","hash":"fdfea28cd785e1ed3980ff7258178ca7ee690f61","modified":1540977936913},{"_id":"public/categories/纪念/index.html","hash":"e014f3ddfbdcd4f30419c2c2f401a114bce403b1","modified":1540977936913},{"_id":"public/tags/Chrome/index.html","hash":"091b8ff280ac9e35d6b1e19c78704ac7ec450c9f","modified":1540977936913},{"_id":"public/tags/DevTools/index.html","hash":"c0f21ac772c804ee3d7725f3ec4b27de1f54d7fd","modified":1540977936913},{"_id":"public/tags/快捷键/index.html","hash":"a4e278b819d533eb7b9ed038c32925a1044220b9","modified":1540977936913},{"_id":"public/tags/Mac/index.html","hash":"aa3eea722a23bb42ece44c33c7d6cbab061647e5","modified":1540977936913},{"_id":"public/tags/CSS/index.html","hash":"abcecb7f556a48ef8986c8cb628cbd330234e6c5","modified":1540977936913},{"_id":"public/tags/规范/index.html","hash":"e614506e5c707115846575b6c4fba8d111438079","modified":1540977936913},{"_id":"public/tags/length/index.html","hash":"496589d68e4cfda504057e88840a13201cbadd34","modified":1540977936913},{"_id":"public/tags/css/index.html","hash":"bfa405933762b34e6476c2ec88669bdfa724f09d","modified":1540977936913},{"_id":"public/tags/HTML5/index.html","hash":"25953283ffae52498dc95d4abad887a06b126f2e","modified":1540977936914},{"_id":"public/tags/标签/index.html","hash":"21d55835f5c6823d2d145bec0bb0ad2682227b7a","modified":1540977936914},{"_id":"public/tags/语义化/index.html","hash":"502ed120a6daef7f5abce976bfd2fb6ee93d7f8e","modified":1540977936914},{"_id":"public/tags/IE/index.html","hash":"7c301631190efe56ff3087a55256d37fcc531a6e","modified":1540977936914},{"_id":"public/tags/兼容性/index.html","hash":"18f52f6f53f5bef30ecfb84ad3c5898aed8748de","modified":1540977936914},{"_id":"public/tags/jQuery/index.html","hash":"c2900dc1c92e1fc807b56e405a20a7dca8109a4f","modified":1540977936914},{"_id":"public/tags/位置/index.html","hash":"e13213cc370dc30ddcb7531341c230490e8c59c3","modified":1540977936914},{"_id":"public/tags/坐标/index.html","hash":"3aa21aa59f518576b7834c33e42ae3c28678f4d5","modified":1540977936914},{"_id":"public/tags/viewport/index.html","hash":"46b57ace0d8d5414babd2db76fa46baee9befb35","modified":1540977936914},{"_id":"public/tags/window/index.html","hash":"aa2f20451bf571825e691bd94141bba9ba660f8c","modified":1540977936914},{"_id":"public/tags/document/index.html","hash":"bbd916a2e3df97cb214a8d9b21448fe7b4b6c406","modified":1540977936914},{"_id":"public/tags/vue/index.html","hash":"fbaee3e2ca9efa2e33c0e3312c6065a71905b3fe","modified":1540977936914},{"_id":"public/tags/文档/index.html","hash":"e819ecd5da0543eb2f5d99944debb57a75c42a14","modified":1540977936914},{"_id":"public/tags/vue2-0/index.html","hash":"4007ea78000a0e3e1b86724c0a4c9a4c9d06b738","modified":1540977936914},{"_id":"public/tags/事件/index.html","hash":"edf185dab674c5bb3ed80c70e620d8a75ad042de","modified":1540977936914},{"_id":"public/tags/HTML/index.html","hash":"79b5cd40021260516561a7f4d7f4abb503aace0c","modified":1540977936915},{"_id":"public/tags/JavaScript/index.html","hash":"f3b0ccb6298ae94edd142d377f8c72369167082b","modified":1540977936915},{"_id":"public/tags/错误监控/index.html","hash":"767e54bc792e591bee40de2e9065b72108f9e7ff","modified":1540977936915},{"_id":"public/tags/你不知道的JavaScript/index.html","hash":"65c89609125b513f75c7169563e6906ebdc9ba34","modified":1540977936915},{"_id":"public/tags/读书笔记/index.html","hash":"85fe1a255753bcf89a3e590625cfd1defc623837","modified":1540977936915},{"_id":"public/tags/爬虫/index.html","hash":"369a83ab59f2e1ffb7bf3fff7d056f1c54824e10","modified":1540977936915},{"_id":"public/tags/Node-js/index.html","hash":"cf20e3971aab5bd042f33fc057300c175131e4d9","modified":1540977936915},{"_id":"public/tags/电子书/index.html","hash":"c4a439f07071af3385b40e760f6a3fb708c8d7e7","modified":1540977936915},{"_id":"public/tags/版权/index.html","hash":"6533fbf17dd69fb1af2c9eb87af0d46ad94bdd4a","modified":1540977936915},{"_id":"public/tags/复盘/index.html","hash":"6bac2546fecbf55889ac56b8d210a9ab343659a9","modified":1540977936915},{"_id":"public/tags/编译/index.html","hash":"06bb094b3309ebc53e8e077333d3bba0e98e0bc0","modified":1540977936915},{"_id":"public/tags/node-modules/index.html","hash":"344b95595a730dc758321fdf70f91917d13d9eca","modified":1540977936915},{"_id":"public/tags/bug/index.html","hash":"c79fbe4613d5e7e4c197365e4b5215d0a9aca313","modified":1540977936915},{"_id":"public/archives/index.html","hash":"c6f95b9c13002d25e27466076600c2d6554db0cb","modified":1540977936915},{"_id":"public/archives/page/2/index.html","hash":"2d432d469aa0cea89f55530e4a739eb17b9f7935","modified":1540977936915},{"_id":"public/archives/2016/index.html","hash":"803b0b1909bb504472cbc54a3b5c7ed41d7d4c7b","modified":1540977936916},{"_id":"public/archives/2016/08/index.html","hash":"a12eddd3d55995169ab0279623bf334c1fe6a49b","modified":1540977936916},{"_id":"public/archives/2016/09/index.html","hash":"a44b2cc69df77807e8888514f998d28ba34e6c88","modified":1540977936916},{"_id":"public/archives/2016/10/index.html","hash":"bacb7f7fc7974834dff0e5543611422d93bc79ad","modified":1540977936916},{"_id":"public/archives/2017/index.html","hash":"bd6f29fc44cd168a456583f7b8b174594ac40b3e","modified":1540977936916},{"_id":"public/archives/2017/01/index.html","hash":"5c7f7b58d1fceb6fda26ef1a749972de55df908f","modified":1540977936916},{"_id":"public/archives/2017/02/index.html","hash":"ab87d68c143c1aa0a0dfc5aafd966290ee0b3988","modified":1540977936916},{"_id":"public/archives/2017/03/index.html","hash":"744fe06b7ed277f62997f92b38970df515019de6","modified":1540977936916},{"_id":"public/archives/2018/index.html","hash":"35c2721559f486eba89244298611d1fc4f379302","modified":1540977936916},{"_id":"public/archives/2018/03/index.html","hash":"ed7534e39efddc69ddec842a16cf50201d9f2991","modified":1540977936916},{"_id":"public/archives/2018/10/index.html","hash":"eaa64114b59850132bd3d43d4cffa7795820f092","modified":1540977936916},{"_id":"public/index.html","hash":"b6e25f770c3214737a8fae33f7ac50f0eef73199","modified":1540977936916},{"_id":"public/page/2/index.html","hash":"0051c4bccbcb533038e05383858d6c6d88d9ef31","modified":1540977936916},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1540977936925},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1540977936925},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1540977936925},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1540977936927},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1540977936927},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1540977936927},{"_id":"public/css/images/favicon.ico","hash":"bfd1a8233f7341ebac7ca6cf5b0eb8f889dffe03","modified":1540977936927},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1540977936927},{"_id":"public/css/images/body.jpg","hash":"92743ba769bb7a7de8e93a418ed36c89e60bc639","modified":1540977936929},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1540977936941},{"_id":"public/js/navigation.js","hash":"1149f4a86285fb1cbf08f3748659368410be6892","modified":1540977936942},{"_id":"public/js/script.js","hash":"dc57599cf47b6a068f6bbc899aad6fda4576b6ae","modified":1540977936942},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1540977936942},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1540977936942},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1540977936942},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1540977936942},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1540977936942},{"_id":"public/css/style.css","hash":"3d96cc35ee33fecb06df65497ee99c322885a936","modified":1540977936942},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1540977936943},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1540977936943},{"_id":"public/js/jquery-2.0.3.min.js","hash":"fbf9c77d0c4e3c34a485980c1e5316b6212160c8","modified":1540977936943},{"_id":"public/css/images/body-real.jpg","hash":"2bbdf623a3b3a421c8de56b8f6853180d2cbabe2","modified":1540977936953}],"Category":[{"name":"css","_id":"cjnwyh59a0006ksk36s0zzpn2"},{"name":"兼容性","_id":"cjnwyh59f000bksk3sar3qrdh"},{"name":"vue","_id":"cjnwyh59k000hksk36jtgfa6r"},{"name":"纪念","_id":"cjnwyh59w0011ksk3wx74fi05"}],"Data":[],"Page":[{"title":"示例页面","id":2,"comment":false,"date":"2016-08-19T11:00:52.000Z","_content":"\n这是一个范例页面。它和博客文章不同，因为它的页面位置是固定的，同时会显示于您的博客导航栏（大多数主题中）。大多数人会新增一个“关于”页面向访客介绍自己。它可能类似下面这样：\n\n> 我是一个很有趣的人，我创建了工厂和庄园。并且，顺便提一下，我的妻子也很好。\n\n……或下面这样：\n\n> XYZ装置公司成立于1971年，公司成立以来，我们一直向市民提供高品质的装置。我们位于北京市，有超过2,000名员工，对北京市有着相当大的贡献。\n\n作为一个新的WordPress用户，您可以前往[您的仪表盘](http://thu.space/wp-admin/)删除这个页面，并建立属于您的全新内容。祝您使用愉快！","source":"sample-page/index.md","raw":"---\ntitle: 示例页面\nid: 2\ncomment: false\ndate: 2016-08-19 19:00:52\n---\n\n这是一个范例页面。它和博客文章不同，因为它的页面位置是固定的，同时会显示于您的博客导航栏（大多数主题中）。大多数人会新增一个“关于”页面向访客介绍自己。它可能类似下面这样：\n\n> 我是一个很有趣的人，我创建了工厂和庄园。并且，顺便提一下，我的妻子也很好。\n\n……或下面这样：\n\n> XYZ装置公司成立于1971年，公司成立以来，我们一直向市民提供高品质的装置。我们位于北京市，有超过2,000名员工，对北京市有着相当大的贡献。\n\n作为一个新的WordPress用户，您可以前往[您的仪表盘](http://thu.space/wp-admin/)删除这个页面，并建立属于您的全新内容。祝您使用愉快！","updated":"2018-10-31T09:05:30.940Z","path":"sample-page/index.html","comments":1,"layout":"page","_id":"cjnwyh5920001ksk3k68ia3d6","content":"<p>这是一个范例页面。它和博客文章不同，因为它的页面位置是固定的，同时会显示于您的博客导航栏（大多数主题中）。大多数人会新增一个“关于”页面向访客介绍自己。它可能类似下面这样：</p>\n<blockquote>\n<p>我是一个很有趣的人，我创建了工厂和庄园。并且，顺便提一下，我的妻子也很好。</p>\n</blockquote>\n<p>……或下面这样：</p>\n<blockquote>\n<p>XYZ装置公司成立于1971年，公司成立以来，我们一直向市民提供高品质的装置。我们位于北京市，有超过2,000名员工，对北京市有着相当大的贡献。</p>\n</blockquote>\n<p>作为一个新的WordPress用户，您可以前往<a href=\"http://thu.space/wp-admin/\" target=\"_blank\" rel=\"noopener\">您的仪表盘</a>删除这个页面，并建立属于您的全新内容。祝您使用愉快！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这是一个范例页面。它和博客文章不同，因为它的页面位置是固定的，同时会显示于您的博客导航栏（大多数主题中）。大多数人会新增一个“关于”页面向访客介绍自己。它可能类似下面这样：</p>\n<blockquote>\n<p>我是一个很有趣的人，我创建了工厂和庄园。并且，顺便提一下，我的妻子也很好。</p>\n</blockquote>\n<p>……或下面这样：</p>\n<blockquote>\n<p>XYZ装置公司成立于1971年，公司成立以来，我们一直向市民提供高品质的装置。我们位于北京市，有超过2,000名员工，对北京市有着相当大的贡献。</p>\n</blockquote>\n<p>作为一个新的WordPress用户，您可以前往<a href=\"http://thu.space/wp-admin/\" target=\"_blank\" rel=\"noopener\">您的仪表盘</a>删除这个页面，并建立属于您的全新内容。祝您使用愉快！</p>\n"}],"Post":[{"title":"Chrome DevTools 重要快捷键(Mac)","date":"2018-03-15T06:17:01.000Z","_content":"# Chrome DevTools 重要快捷键(Mac)\n## 访问 DevTools\n打开/切换检查元素模式和浏览器窗口  Cmd + Shift + C\n打开 Developer Tools 并聚焦到控制台  Cmd + Opt + J\n\n## 全局\n显示设置  ?\n上/下一个面板  Cmd + [/]\n更改停靠位置  Cmd + Shift + D\nDevice Mode  Cmd + Shift + M\n切换控制台 ESC\n在所有源中搜索文本 Cmd + Opt + F\n按文件名搜索（除了在 Timeline 上）  Cmd + O、Cmd + P\n\n## Elements\n展开/折叠节点及其所有子节点  Opt + 点击箭头图标\n隐藏元素  H\n切换为以 HTML 形式编辑  F2\n\n## style\n转到源中样式规则属性声明行  Cmd + 点击属性\n在颜色定义值之间循环  Shift + 点击颜色选取器框\n编辑下一个/上一个属性  Tab、Shift + Tab\n以 10 为增量增大/减小值  Shift + Up、Shift + Down  \tPgUp、PgDown\n以 100 为增量增大/减小值  Shift + PgUp、Shift + PgDown\n以 0.1 为增量增大/减小值  Opt + 向上键、Opt + 向下键\n\n## Sources\n暂停/继续脚本执行  \tF8、Cmd + \\\n越过下一个函数调用  F10、Cmd + '\n进入下一个函数调用  F11、Cmd + ;\n跳出当前函数  Shift + F11、Cmd + Shift + ;\n转到行  Ctrl + G\n转到成员  Cmd + Shift + O","source":"_posts/Chrome-DevTools-重要快捷键-Mac.md","raw":"---\ntitle: Chrome DevTools 重要快捷键(Mac)\ndate: 2018-03-15 14:17:01\ntags:\n    - Chrome\n    - DevTools\n    - 快捷键\n    - Mac\n---\n# Chrome DevTools 重要快捷键(Mac)\n## 访问 DevTools\n打开/切换检查元素模式和浏览器窗口  Cmd + Shift + C\n打开 Developer Tools 并聚焦到控制台  Cmd + Opt + J\n\n## 全局\n显示设置  ?\n上/下一个面板  Cmd + [/]\n更改停靠位置  Cmd + Shift + D\nDevice Mode  Cmd + Shift + M\n切换控制台 ESC\n在所有源中搜索文本 Cmd + Opt + F\n按文件名搜索（除了在 Timeline 上）  Cmd + O、Cmd + P\n\n## Elements\n展开/折叠节点及其所有子节点  Opt + 点击箭头图标\n隐藏元素  H\n切换为以 HTML 形式编辑  F2\n\n## style\n转到源中样式规则属性声明行  Cmd + 点击属性\n在颜色定义值之间循环  Shift + 点击颜色选取器框\n编辑下一个/上一个属性  Tab、Shift + Tab\n以 10 为增量增大/减小值  Shift + Up、Shift + Down  \tPgUp、PgDown\n以 100 为增量增大/减小值  Shift + PgUp、Shift + PgDown\n以 0.1 为增量增大/减小值  Opt + 向上键、Opt + 向下键\n\n## Sources\n暂停/继续脚本执行  \tF8、Cmd + \\\n越过下一个函数调用  F10、Cmd + '\n进入下一个函数调用  F11、Cmd + ;\n跳出当前函数  Shift + F11、Cmd + Shift + ;\n转到行  Ctrl + G\n转到成员  Cmd + Shift + O","slug":"Chrome-DevTools-重要快捷键-Mac","published":1,"updated":"2018-10-31T09:05:30.931Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnwyh58y0000ksk3x6as7l5l","content":"<h1 id=\"Chrome-DevTools-重要快捷键-Mac\"><a href=\"#Chrome-DevTools-重要快捷键-Mac\" class=\"headerlink\" title=\"Chrome DevTools 重要快捷键(Mac)\"></a>Chrome DevTools 重要快捷键(Mac)</h1><h2 id=\"访问-DevTools\"><a href=\"#访问-DevTools\" class=\"headerlink\" title=\"访问 DevTools\"></a>访问 DevTools</h2><p>打开/切换检查元素模式和浏览器窗口  Cmd + Shift + C<br>打开 Developer Tools 并聚焦到控制台  Cmd + Opt + J</p>\n<h2 id=\"全局\"><a href=\"#全局\" class=\"headerlink\" title=\"全局\"></a>全局</h2><p>显示设置  ?<br>上/下一个面板  Cmd + [/]<br>更改停靠位置  Cmd + Shift + D<br>Device Mode  Cmd + Shift + M<br>切换控制台 ESC<br>在所有源中搜索文本 Cmd + Opt + F<br>按文件名搜索（除了在 Timeline 上）  Cmd + O、Cmd + P</p>\n<h2 id=\"Elements\"><a href=\"#Elements\" class=\"headerlink\" title=\"Elements\"></a>Elements</h2><p>展开/折叠节点及其所有子节点  Opt + 点击箭头图标<br>隐藏元素  H<br>切换为以 HTML 形式编辑  F2</p>\n<h2 id=\"style\"><a href=\"#style\" class=\"headerlink\" title=\"style\"></a>style</h2><p>转到源中样式规则属性声明行  Cmd + 点击属性<br>在颜色定义值之间循环  Shift + 点击颜色选取器框<br>编辑下一个/上一个属性  Tab、Shift + Tab<br>以 10 为增量增大/减小值  Shift + Up、Shift + Down      PgUp、PgDown<br>以 100 为增量增大/减小值  Shift + PgUp、Shift + PgDown<br>以 0.1 为增量增大/减小值  Opt + 向上键、Opt + 向下键</p>\n<h2 id=\"Sources\"><a href=\"#Sources\" class=\"headerlink\" title=\"Sources\"></a>Sources</h2><p>暂停/继续脚本执行      F8、Cmd + \\<br>越过下一个函数调用  F10、Cmd + ‘<br>进入下一个函数调用  F11、Cmd + ;<br>跳出当前函数  Shift + F11、Cmd + Shift + ;<br>转到行  Ctrl + G<br>转到成员  Cmd + Shift + O</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Chrome-DevTools-重要快捷键-Mac\"><a href=\"#Chrome-DevTools-重要快捷键-Mac\" class=\"headerlink\" title=\"Chrome DevTools 重要快捷键(Mac)\"></a>Chrome DevTools 重要快捷键(Mac)</h1><h2 id=\"访问-DevTools\"><a href=\"#访问-DevTools\" class=\"headerlink\" title=\"访问 DevTools\"></a>访问 DevTools</h2><p>打开/切换检查元素模式和浏览器窗口  Cmd + Shift + C<br>打开 Developer Tools 并聚焦到控制台  Cmd + Opt + J</p>\n<h2 id=\"全局\"><a href=\"#全局\" class=\"headerlink\" title=\"全局\"></a>全局</h2><p>显示设置  ?<br>上/下一个面板  Cmd + [/]<br>更改停靠位置  Cmd + Shift + D<br>Device Mode  Cmd + Shift + M<br>切换控制台 ESC<br>在所有源中搜索文本 Cmd + Opt + F<br>按文件名搜索（除了在 Timeline 上）  Cmd + O、Cmd + P</p>\n<h2 id=\"Elements\"><a href=\"#Elements\" class=\"headerlink\" title=\"Elements\"></a>Elements</h2><p>展开/折叠节点及其所有子节点  Opt + 点击箭头图标<br>隐藏元素  H<br>切换为以 HTML 形式编辑  F2</p>\n<h2 id=\"style\"><a href=\"#style\" class=\"headerlink\" title=\"style\"></a>style</h2><p>转到源中样式规则属性声明行  Cmd + 点击属性<br>在颜色定义值之间循环  Shift + 点击颜色选取器框<br>编辑下一个/上一个属性  Tab、Shift + Tab<br>以 10 为增量增大/减小值  Shift + Up、Shift + Down      PgUp、PgDown<br>以 100 为增量增大/减小值  Shift + PgUp、Shift + PgDown<br>以 0.1 为增量增大/减小值  Opt + 向上键、Opt + 向下键</p>\n<h2 id=\"Sources\"><a href=\"#Sources\" class=\"headerlink\" title=\"Sources\"></a>Sources</h2><p>暂停/继续脚本执行      F8、Cmd + \\<br>越过下一个函数调用  F10、Cmd + ‘<br>进入下一个函数调用  F11、Cmd + ;<br>跳出当前函数  Shift + F11、Cmd + Shift + ;<br>转到行  Ctrl + G<br>转到成员  Cmd + Shift + O</p>\n"},{"title":"CSS px","date":"2017-03-03T04:52:06.000Z","_content":"px在CSS中指CSS像素,是相对于**设备像素**的**相对值**.\n在W3C的[Web Style Sheets CSS tips & tricks](https://www.w3.org/Style/Examples/007/units.en.html)中提到\n\n> In fact, CSS requires that 1px must be exactly 1/96th of an inch in all printed output.\n\n所以这就很明白了.\n比如iPhone 5使用的是Retina视网膜屏幕，使用2px x 2px的 device pixel 代表 1px x 1px 的 css pixel，所以设备像素数为640 x 1136px，而CSS逻辑像素数为320 x 568px。\n需要用的时候,注意换算**像素**比就是了.","source":"_posts/CSS-px.md","raw":"---\ntitle: CSS px\ndate: 2017-03-03 12:52:06\ntags:\n    - CSS\n    - 规范\n    - length\n---\npx在CSS中指CSS像素,是相对于**设备像素**的**相对值**.\n在W3C的[Web Style Sheets CSS tips & tricks](https://www.w3.org/Style/Examples/007/units.en.html)中提到\n\n> In fact, CSS requires that 1px must be exactly 1/96th of an inch in all printed output.\n\n所以这就很明白了.\n比如iPhone 5使用的是Retina视网膜屏幕，使用2px x 2px的 device pixel 代表 1px x 1px 的 css pixel，所以设备像素数为640 x 1136px，而CSS逻辑像素数为320 x 568px。\n需要用的时候,注意换算**像素**比就是了.","slug":"CSS-px","published":1,"updated":"2018-10-31T09:05:30.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnwyh5930002ksk3xtgf31uv","content":"<p>px在CSS中指CSS像素,是相对于<strong>设备像素</strong>的<strong>相对值</strong>.<br>在W3C的<a href=\"https://www.w3.org/Style/Examples/007/units.en.html\" target=\"_blank\" rel=\"noopener\">Web Style Sheets CSS tips &amp; tricks</a>中提到</p>\n<blockquote>\n<p>In fact, CSS requires that 1px must be exactly 1/96th of an inch in all printed output.</p>\n</blockquote>\n<p>所以这就很明白了.<br>比如iPhone 5使用的是Retina视网膜屏幕，使用2px x 2px的 device pixel 代表 1px x 1px 的 css pixel，所以设备像素数为640 x 1136px，而CSS逻辑像素数为320 x 568px。<br>需要用的时候,注意换算<strong>像素</strong>比就是了.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>px在CSS中指CSS像素,是相对于<strong>设备像素</strong>的<strong>相对值</strong>.<br>在W3C的<a href=\"https://www.w3.org/Style/Examples/007/units.en.html\" target=\"_blank\" rel=\"noopener\">Web Style Sheets CSS tips &amp; tricks</a>中提到</p>\n<blockquote>\n<p>In fact, CSS requires that 1px must be exactly 1/96th of an inch in all printed output.</p>\n</blockquote>\n<p>所以这就很明白了.<br>比如iPhone 5使用的是Retina视网膜屏幕，使用2px x 2px的 device pixel 代表 1px x 1px 的 css pixel，所以设备像素数为640 x 1136px，而CSS逻辑像素数为320 x 568px。<br>需要用的时候,注意换算<strong>像素</strong>比就是了.</p>\n"},{"title":"css 细节","id":"7","date":"2016-08-22T08:35:15.000Z","_content":"\n1.  position包含块\n    *   relative、static包含块由最近的块级框、表单元格或行内块祖先框的**内容边界**构成。\n    *   absolute包含块设置为最近的position不是static的祖先元素（可以是任何类型），如果这个祖先元素是块级元素，包含块则设置为该块元素的**内边距边界**，换句话说，就是由边框界定的区域。\n\n2.  百分数数值计算\n    *   top、bottom相对于包含块**高度**计算，与此同时padding、margin四个方向的计算**全部**基于包含块**宽度。**\n    *   border**不接受**百分数。\n    *   height相对于包含块**高度**\n\n3.  overflow:hidden\n\t满足以下两点要求的子元素仍旧会在这种情况下溢出\n\t* 拥有overflow:hidden样式的块元素不具有position:relative和position:absolute样式；\n\t* 内部溢出的元素是通过position:absolute绝对定位；\n\n\t原理待补充.","source":"_posts/css-e7-bb-86-e8-8a-82.md","raw":"---\ntitle: css 细节\ntags:\n  - css\nid: 7\ncategories:\n  - css\ndate: 2016-08-22 16:35:15\n---\n\n1.  position包含块\n    *   relative、static包含块由最近的块级框、表单元格或行内块祖先框的**内容边界**构成。\n    *   absolute包含块设置为最近的position不是static的祖先元素（可以是任何类型），如果这个祖先元素是块级元素，包含块则设置为该块元素的**内边距边界**，换句话说，就是由边框界定的区域。\n\n2.  百分数数值计算\n    *   top、bottom相对于包含块**高度**计算，与此同时padding、margin四个方向的计算**全部**基于包含块**宽度。**\n    *   border**不接受**百分数。\n    *   height相对于包含块**高度**\n\n3.  overflow:hidden\n\t满足以下两点要求的子元素仍旧会在这种情况下溢出\n\t* 拥有overflow:hidden样式的块元素不具有position:relative和position:absolute样式；\n\t* 内部溢出的元素是通过position:absolute绝对定位；\n\n\t原理待补充.","slug":"css-e7-bb-86-e8-8a-82","published":1,"updated":"2018-10-31T09:05:30.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnwyh5970004ksk3mvhr04u7","content":"<ol>\n<li><p>position包含块</p>\n<ul>\n<li>relative、static包含块由最近的块级框、表单元格或行内块祖先框的<strong>内容边界</strong>构成。</li>\n<li>absolute包含块设置为最近的position不是static的祖先元素（可以是任何类型），如果这个祖先元素是块级元素，包含块则设置为该块元素的<strong>内边距边界</strong>，换句话说，就是由边框界定的区域。</li>\n</ul>\n</li>\n<li><p>百分数数值计算</p>\n<ul>\n<li>top、bottom相对于包含块<strong>高度</strong>计算，与此同时padding、margin四个方向的计算<strong>全部</strong>基于包含块<strong>宽度。</strong></li>\n<li>border<strong>不接受</strong>百分数。</li>\n<li>height相对于包含块<strong>高度</strong></li>\n</ul>\n</li>\n<li><p>overflow:hidden<br>满足以下两点要求的子元素仍旧会在这种情况下溢出</p>\n<ul>\n<li>拥有overflow:hidden样式的块元素不具有position:relative和position:absolute样式；</li>\n<li>内部溢出的元素是通过position:absolute绝对定位；</li>\n</ul>\n<p>原理待补充.</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>position包含块</p>\n<ul>\n<li>relative、static包含块由最近的块级框、表单元格或行内块祖先框的<strong>内容边界</strong>构成。</li>\n<li>absolute包含块设置为最近的position不是static的祖先元素（可以是任何类型），如果这个祖先元素是块级元素，包含块则设置为该块元素的<strong>内边距边界</strong>，换句话说，就是由边框界定的区域。</li>\n</ul>\n</li>\n<li><p>百分数数值计算</p>\n<ul>\n<li>top、bottom相对于包含块<strong>高度</strong>计算，与此同时padding、margin四个方向的计算<strong>全部</strong>基于包含块<strong>宽度。</strong></li>\n<li>border<strong>不接受</strong>百分数。</li>\n<li>height相对于包含块<strong>高度</strong></li>\n</ul>\n</li>\n<li><p>overflow:hidden<br>满足以下两点要求的子元素仍旧会在这种情况下溢出</p>\n<ul>\n<li>拥有overflow:hidden样式的块元素不具有position:relative和position:absolute样式；</li>\n<li>内部溢出的元素是通过position:absolute绝对定位；</li>\n</ul>\n<p>原理待补充.</p>\n</li>\n</ol>\n"},{"title":"HTML5标签辨析","date":"2016-10-07T16:09:38.000Z","_content":"这篇文章记录对HTML5一些标签的辨析\n*不涉及任何HTML5之前的语义!*\n1. em strong\n * strong表示HTML页面上的强调(emphasized text),em表示句子中的强调(即强调语义);\n * storg被描述为表征“内容强烈的重要性(strong importance for its contents) ”。这是一个重要的区别。em标签(Emphasis)用于改变一个句子的意思(\"我*喜欢*胡萝卜\" 或\"我喜欢*胡萝卜*\"), strong用来对一个句子的部分增加重要性(比如 \"**警告**! 这**非常危险**。\")\n * Strong和Emphasis都可以分别通过嵌套来增加重要性或强调的相对强度。\n2. b i\n * b元素:\n \tThe b element now represents a span of text to be stylistically offset from the normal prose without conveying any extra importance, such as key words in a document abstract, product names in a review, or other spans of text whose typical typographic presentation is emboldened.(b 元素现在描述为在普通文章中仅从文体上突出的不包含任何额外的重要性的一段文本。例如：文档概要中的关键字，评论中的产品名。或者代表强调的排版方式。)\n * i元素:\n \tThe i element now represents a span of text in an alternate voice or mood, or otherwise offset from the normal prose, such as a taxonomic designation, a technical term, an idiomatic phrase from another language, a thought, a ship name, or some other prose whose typical typographic presentation is italicized. Usage varies widely by language.(i 元素现在描述为在普通文章中突出不同意见或语气或其他的一段文本，例如：一个分类名称，一个技术术语，一个外语中的谚语，一个想法等。或者代表斜体的排版方式。)\n","source":"_posts/html5标签辨析.md","raw":"---\ntitle: HTML5标签辨析\ndate: 2016-10-08 00:09:38\ntags:\n\t- HTML5\n\t- 标签\n\t- 语义化\n---\n这篇文章记录对HTML5一些标签的辨析\n*不涉及任何HTML5之前的语义!*\n1. em strong\n * strong表示HTML页面上的强调(emphasized text),em表示句子中的强调(即强调语义);\n * storg被描述为表征“内容强烈的重要性(strong importance for its contents) ”。这是一个重要的区别。em标签(Emphasis)用于改变一个句子的意思(\"我*喜欢*胡萝卜\" 或\"我喜欢*胡萝卜*\"), strong用来对一个句子的部分增加重要性(比如 \"**警告**! 这**非常危险**。\")\n * Strong和Emphasis都可以分别通过嵌套来增加重要性或强调的相对强度。\n2. b i\n * b元素:\n \tThe b element now represents a span of text to be stylistically offset from the normal prose without conveying any extra importance, such as key words in a document abstract, product names in a review, or other spans of text whose typical typographic presentation is emboldened.(b 元素现在描述为在普通文章中仅从文体上突出的不包含任何额外的重要性的一段文本。例如：文档概要中的关键字，评论中的产品名。或者代表强调的排版方式。)\n * i元素:\n \tThe i element now represents a span of text in an alternate voice or mood, or otherwise offset from the normal prose, such as a taxonomic designation, a technical term, an idiomatic phrase from another language, a thought, a ship name, or some other prose whose typical typographic presentation is italicized. Usage varies widely by language.(i 元素现在描述为在普通文章中突出不同意见或语气或其他的一段文本，例如：一个分类名称，一个技术术语，一个外语中的谚语，一个想法等。或者代表斜体的排版方式。)\n","slug":"html5标签辨析","published":1,"updated":"2018-10-31T09:05:30.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnwyh5980005ksk3no87lmd1","content":"<p>这篇文章记录对HTML5一些标签的辨析<br><em>不涉及任何HTML5之前的语义!</em></p>\n<ol>\n<li>em strong<ul>\n<li>strong表示HTML页面上的强调(emphasized text),em表示句子中的强调(即强调语义);</li>\n<li>storg被描述为表征“内容强烈的重要性(strong importance for its contents) ”。这是一个重要的区别。em标签(Emphasis)用于改变一个句子的意思(“我<em>喜欢</em>胡萝卜” 或”我喜欢<em>胡萝卜</em>“), strong用来对一个句子的部分增加重要性(比如 “<strong>警告</strong>! 这<strong>非常危险</strong>。”)</li>\n<li>Strong和Emphasis都可以分别通过嵌套来增加重要性或强调的相对强度。</li>\n</ul>\n</li>\n<li>b i<ul>\n<li>b元素:<br>The b element now represents a span of text to be stylistically offset from the normal prose without conveying any extra importance, such as key words in a document abstract, product names in a review, or other spans of text whose typical typographic presentation is emboldened.(b 元素现在描述为在普通文章中仅从文体上突出的不包含任何额外的重要性的一段文本。例如：文档概要中的关键字，评论中的产品名。或者代表强调的排版方式。)</li>\n<li>i元素:<br>The i element now represents a span of text in an alternate voice or mood, or otherwise offset from the normal prose, such as a taxonomic designation, a technical term, an idiomatic phrase from another language, a thought, a ship name, or some other prose whose typical typographic presentation is italicized. Usage varies widely by language.(i 元素现在描述为在普通文章中突出不同意见或语气或其他的一段文本，例如：一个分类名称，一个技术术语，一个外语中的谚语，一个想法等。或者代表斜体的排版方式。)</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>这篇文章记录对HTML5一些标签的辨析<br><em>不涉及任何HTML5之前的语义!</em></p>\n<ol>\n<li>em strong<ul>\n<li>strong表示HTML页面上的强调(emphasized text),em表示句子中的强调(即强调语义);</li>\n<li>storg被描述为表征“内容强烈的重要性(strong importance for its contents) ”。这是一个重要的区别。em标签(Emphasis)用于改变一个句子的意思(“我<em>喜欢</em>胡萝卜” 或”我喜欢<em>胡萝卜</em>“), strong用来对一个句子的部分增加重要性(比如 “<strong>警告</strong>! 这<strong>非常危险</strong>。”)</li>\n<li>Strong和Emphasis都可以分别通过嵌套来增加重要性或强调的相对强度。</li>\n</ul>\n</li>\n<li>b i<ul>\n<li>b元素:<br>The b element now represents a span of text to be stylistically offset from the normal prose without conveying any extra importance, such as key words in a document abstract, product names in a review, or other spans of text whose typical typographic presentation is emboldened.(b 元素现在描述为在普通文章中仅从文体上突出的不包含任何额外的重要性的一段文本。例如：文档概要中的关键字，评论中的产品名。或者代表强调的排版方式。)</li>\n<li>i元素:<br>The i element now represents a span of text in an alternate voice or mood, or otherwise offset from the normal prose, such as a taxonomic designation, a technical term, an idiomatic phrase from another language, a thought, a ship name, or some other prose whose typical typographic presentation is italicized. Usage varies widely by language.(i 元素现在描述为在普通文章中突出不同意见或语气或其他的一段文本，例如：一个分类名称，一个技术术语，一个外语中的谚语，一个想法等。或者代表斜体的排版方式。)</li>\n</ul>\n</li>\n</ol>\n"},{"title":"兼容性tips","id":"20","date":"2016-09-09T11:51:11.000Z","_content":"\n1.  IE 10 及以下a标签里定义的img会被赋予一个边框\n    原因是浏览器通常会把代表超链接的图像（例如包含在 a 标签中的图像）显示在两个像素宽的边框里面，以表示读者可以通过选择这个图像来访问相关联的文档。 因为没有边框就意味着去掉了一种非常常见的超链接视觉指示效果，这使得读者可能不会像原来那么很容易就可以找到这些链接。","source":"_posts/e5-85-bc-e5-ae-b9-e6-80-a7tips.md","raw":"---\ntitle: 兼容性tips\ntags:\n  - IE\n  - 兼容性\nid: 20\ncategories:\n  - 兼容性\ndate: 2016-09-09 19:51:11\n---\n\n1.  IE 10 及以下a标签里定义的img会被赋予一个边框\n    原因是浏览器通常会把代表超链接的图像（例如包含在 a 标签中的图像）显示在两个像素宽的边框里面，以表示读者可以通过选择这个图像来访问相关联的文档。 因为没有边框就意味着去掉了一种非常常见的超链接视觉指示效果，这使得读者可能不会像原来那么很容易就可以找到这些链接。","slug":"e5-85-bc-e5-ae-b9-e6-80-a7tips","published":1,"updated":"2018-10-31T09:05:30.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnwyh59b0007ksk3gvoe6j5l","content":"<ol>\n<li>IE 10 及以下a标签里定义的img会被赋予一个边框<br>原因是浏览器通常会把代表超链接的图像（例如包含在 a 标签中的图像）显示在两个像素宽的边框里面，以表示读者可以通过选择这个图像来访问相关联的文档。 因为没有边框就意味着去掉了一种非常常见的超链接视觉指示效果，这使得读者可能不会像原来那么很容易就可以找到这些链接。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>IE 10 及以下a标签里定义的img会被赋予一个边框<br>原因是浏览器通常会把代表超链接的图像（例如包含在 a 标签中的图像）显示在两个像素宽的边框里面，以表示读者可以通过选择这个图像来访问相关联的文档。 因为没有边框就意味着去掉了一种非常常见的超链接视觉指示效果，这使得读者可能不会像原来那么很容易就可以找到这些链接。</li>\n</ol>\n"},{"title":"行内元素完整换行","date":"2017-01-27T03:32:26.000Z","_content":"有这样一个需求,各个标签用行内元素(例如span)包裹(这样做往往是考虑到HTML语义),当容器宽度不足时,*完整换行*,即当行内剩余空间不足展示一个标签时,换行,而非标签内分断.\n稍有常识的人一定知道,直接用span是不行的.\n解决的方案当然也是十分简单,设置这些span的display属性为inline-block就可以了.\n值得吐槽的是,chrome显示的行内元素的padding区域在出现换行的时候,会在每一行都显示,这样就会出现除最后一行外,其他行的内容会在\"padding区域\"(实际上并不是)显示,可能会对一些新手造成困扰.\nFirefox显示正常.\n","source":"_posts/span换行.md","raw":"---\ntitle: 行内元素完整换行\ndate: 2017-01-27 11:32:26\ntags:\n---\n有这样一个需求,各个标签用行内元素(例如span)包裹(这样做往往是考虑到HTML语义),当容器宽度不足时,*完整换行*,即当行内剩余空间不足展示一个标签时,换行,而非标签内分断.\n稍有常识的人一定知道,直接用span是不行的.\n解决的方案当然也是十分简单,设置这些span的display属性为inline-block就可以了.\n值得吐槽的是,chrome显示的行内元素的padding区域在出现换行的时候,会在每一行都显示,这样就会出现除最后一行外,其他行的内容会在\"padding区域\"(实际上并不是)显示,可能会对一些新手造成困扰.\nFirefox显示正常.\n","slug":"span换行","published":1,"updated":"2018-10-31T09:05:30.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnwyh59c0009ksk3t250cdkr","content":"<p>有这样一个需求,各个标签用行内元素(例如span)包裹(这样做往往是考虑到HTML语义),当容器宽度不足时,<em>完整换行</em>,即当行内剩余空间不足展示一个标签时,换行,而非标签内分断.<br>稍有常识的人一定知道,直接用span是不行的.<br>解决的方案当然也是十分简单,设置这些span的display属性为inline-block就可以了.<br>值得吐槽的是,chrome显示的行内元素的padding区域在出现换行的时候,会在每一行都显示,这样就会出现除最后一行外,其他行的内容会在”padding区域”(实际上并不是)显示,可能会对一些新手造成困扰.<br>Firefox显示正常.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>有这样一个需求,各个标签用行内元素(例如span)包裹(这样做往往是考虑到HTML语义),当容器宽度不足时,<em>完整换行</em>,即当行内剩余空间不足展示一个标签时,换行,而非标签内分断.<br>稍有常识的人一定知道,直接用span是不行的.<br>解决的方案当然也是十分简单,设置这些span的display属性为inline-block就可以了.<br>值得吐槽的是,chrome显示的行内元素的padding区域在出现换行的时候,会在每一行都显示,这样就会出现除最后一行外,其他行的内容会在”padding区域”(实际上并不是)显示,可能会对一些新手造成困扰.<br>Firefox显示正常.</p>\n"},{"title":"jQuery offset()","date":"2018-03-19T06:58:37.000Z","_content":"\n## 定义\n\n.offset()方法返回对应元素边框盒（包括外边距）*基于文档*的坐标值。\nThe .offset() method allows us to retrieve the current position of an element (specifically its border box, which excludes margins) *relative to the document*.\n\n## 核心源码\n\n```js\n// Get document-relative position by adding viewport scroll to viewport-relative gBCR\nrect = elem.getBoundingClientRect();\nwin = elem.ownerDocument.defaultView;\nreturn {\n    top: rect.top + win.pageYOffset,\n    left: rect.left + win.pageXOffset\n};\n```\n\ngetBoundingClientRect返回的是*基于视口*的坐标。\n如果不希望属性值随视口变化，那么只要给top、left属性值加上当前的滚动位置（通过window.scrollX和window.scrollY），这样就可以获取与当前的滚动位置无关的（*基于文档的*）常量值。\n\n## 视口，窗口，文档\n* 视口（viewport）：当前浏览器可视区域\n* 窗口（window）：当前浏览器\n* 文档（document）：当前文档\n\n\n","source":"_posts/jQuery-offset.md","raw":"---\ntitle: jQuery offset()\ndate: 2018-03-19 14:58:37\ntags:\n    - jQuery\n    - 位置\n    - 坐标\n    - viewport\n    - window\n    - document\n---\n\n## 定义\n\n.offset()方法返回对应元素边框盒（包括外边距）*基于文档*的坐标值。\nThe .offset() method allows us to retrieve the current position of an element (specifically its border box, which excludes margins) *relative to the document*.\n\n## 核心源码\n\n```js\n// Get document-relative position by adding viewport scroll to viewport-relative gBCR\nrect = elem.getBoundingClientRect();\nwin = elem.ownerDocument.defaultView;\nreturn {\n    top: rect.top + win.pageYOffset,\n    left: rect.left + win.pageXOffset\n};\n```\n\ngetBoundingClientRect返回的是*基于视口*的坐标。\n如果不希望属性值随视口变化，那么只要给top、left属性值加上当前的滚动位置（通过window.scrollX和window.scrollY），这样就可以获取与当前的滚动位置无关的（*基于文档的*）常量值。\n\n## 视口，窗口，文档\n* 视口（viewport）：当前浏览器可视区域\n* 窗口（window）：当前浏览器\n* 文档（document）：当前文档\n\n\n","slug":"jQuery-offset","published":1,"updated":"2018-10-31T09:05:30.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnwyh59e000aksk3es7ddx1u","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>.offset()方法返回对应元素边框盒（包括外边距）<em>基于文档</em>的坐标值。<br>The .offset() method allows us to retrieve the current position of an element (specifically its border box, which excludes margins) <em>relative to the document</em>.</p>\n<h2 id=\"核心源码\"><a href=\"#核心源码\" class=\"headerlink\" title=\"核心源码\"></a>核心源码</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Get document-relative position by adding viewport scroll to viewport-relative gBCR</span></span><br><span class=\"line\">rect = elem.getBoundingClientRect();</span><br><span class=\"line\">win = elem.ownerDocument.defaultView;</span><br><span class=\"line\"><span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    top: rect.top + win.pageYOffset,</span><br><span class=\"line\">    left: rect.left + win.pageXOffset</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>getBoundingClientRect返回的是<em>基于视口</em>的坐标。<br>如果不希望属性值随视口变化，那么只要给top、left属性值加上当前的滚动位置（通过window.scrollX和window.scrollY），这样就可以获取与当前的滚动位置无关的（<em>基于文档的</em>）常量值。</p>\n<h2 id=\"视口，窗口，文档\"><a href=\"#视口，窗口，文档\" class=\"headerlink\" title=\"视口，窗口，文档\"></a>视口，窗口，文档</h2><ul>\n<li>视口（viewport）：当前浏览器可视区域</li>\n<li>窗口（window）：当前浏览器</li>\n<li>文档（document）：当前文档</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>.offset()方法返回对应元素边框盒（包括外边距）<em>基于文档</em>的坐标值。<br>The .offset() method allows us to retrieve the current position of an element (specifically its border box, which excludes margins) <em>relative to the document</em>.</p>\n<h2 id=\"核心源码\"><a href=\"#核心源码\" class=\"headerlink\" title=\"核心源码\"></a>核心源码</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Get document-relative position by adding viewport scroll to viewport-relative gBCR</span></span><br><span class=\"line\">rect = elem.getBoundingClientRect();</span><br><span class=\"line\">win = elem.ownerDocument.defaultView;</span><br><span class=\"line\"><span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    top: rect.top + win.pageYOffset,</span><br><span class=\"line\">    left: rect.left + win.pageXOffset</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>getBoundingClientRect返回的是<em>基于视口</em>的坐标。<br>如果不希望属性值随视口变化，那么只要给top、left属性值加上当前的滚动位置（通过window.scrollX和window.scrollY），这样就可以获取与当前的滚动位置无关的（<em>基于文档的</em>）常量值。</p>\n<h2 id=\"视口，窗口，文档\"><a href=\"#视口，窗口，文档\" class=\"headerlink\" title=\"视口，窗口，文档\"></a>视口，窗口，文档</h2><ul>\n<li>视口（viewport）：当前浏览器可视区域</li>\n<li>窗口（window）：当前浏览器</li>\n<li>文档（document）：当前文档</li>\n</ul>\n"},{"title":"vue 2.0 Changes","id":"5","date":"2016-08-22T03:00:56.000Z","_content":"\n### High Level Changes\n\n*   模板解析不再依赖DOM（除非你使用DOM本身作为你的模板），所以只要你使用字符串模板（&lt;script type=\"text/x-template\"&gt;/*译注：YUI类库自己定义的元素type，用于存放html减少DOM节点*/,内联JavaScript字符串，或者经由单文件组件编译而成的字符串模板），你不再需要面对任何1.x版本中的模板解析局限。然而，如果你（使用el选项）将现存的内容绑定到元素上作为模板，你依旧将面临那些局限。","source":"_posts/vue-2-0-changes.md","raw":"---\ntitle: vue 2.0 Changes\ntags:\n  - vue\n  - 文档\nid: 5\ncategories:\n  - vue\ndate: 2016-08-22 11:00:56\n---\n\n### High Level Changes\n\n*   模板解析不再依赖DOM（除非你使用DOM本身作为你的模板），所以只要你使用字符串模板（&lt;script type=\"text/x-template\"&gt;/*译注：YUI类库自己定义的元素type，用于存放html减少DOM节点*/,内联JavaScript字符串，或者经由单文件组件编译而成的字符串模板），你不再需要面对任何1.x版本中的模板解析局限。然而，如果你（使用el选项）将现存的内容绑定到元素上作为模板，你依旧将面临那些局限。","slug":"vue-2-0-changes","published":1,"updated":"2018-10-31T09:05:30.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnwyh59f000dksk329ltmjfz","content":"<h3 id=\"High-Level-Changes\"><a href=\"#High-Level-Changes\" class=\"headerlink\" title=\"High Level Changes\"></a>High Level Changes</h3><ul>\n<li>模板解析不再依赖DOM（除非你使用DOM本身作为你的模板），所以只要你使用字符串模板（&lt;script type=”text/x-template”&gt;/<em>译注：YUI类库自己定义的元素type，用于存放html减少DOM节点</em>/,内联JavaScript字符串，或者经由单文件组件编译而成的字符串模板），你不再需要面对任何1.x版本中的模板解析局限。然而，如果你（使用el选项）将现存的内容绑定到元素上作为模板，你依旧将面临那些局限。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"High-Level-Changes\"><a href=\"#High-Level-Changes\" class=\"headerlink\" title=\"High Level Changes\"></a>High Level Changes</h3><ul>\n<li>模板解析不再依赖DOM（除非你使用DOM本身作为你的模板），所以只要你使用字符串模板（&lt;script type=”text/x-template”&gt;/<em>译注：YUI类库自己定义的元素type，用于存放html减少DOM节点</em>/,内联JavaScript字符串，或者经由单文件组件编译而成的字符串模板），你不再需要面对任何1.x版本中的模板解析局限。然而，如果你（使用el选项）将现存的内容绑定到元素上作为模板，你依旧将面临那些局限。</li>\n</ul>\n"},{"title":"vue2.0踩坑之旅","id":"9","date":"2016-08-22T11:13:48.000Z","_content":"\n#升级Vue\n##引入Vue\nVue升级2.0，将compiler与runtime 分开，分成两个build，分别是:\n\n-Standalone build: includes both the compiler and the runtime. This functions basically exactly the same Vue 1.x does.\n\n-Runtime only build:since it doesn't include the compiler, you need to either pre-compiled templates in a compile step, or manually written render functions. The npm package will export this build by default, since when consuming Vue from npm, you will likely be using a compilation step (with Browserify or Webpack), during which vueif or vue-loader will perform the template pre-compilation.\n\n默认引入Runtime only build，而我们在不想要改变过去的一系列构建模式的前提下，需要引入Standalone build，路径是'vue/dist/vue.js'(Runtime only build引入的实际上也是dist文件下的文件)\n\n##生命周期钩子\n一定要注意vue2.0对生命周期钩子函数的大量改动：\ninit -> beforeCreate\n created\n beforeDestroy\n destroyed\n beforeMount(new)\n mounte(new)\n beforeUpdate(new)\n updated(new)\n activated (new) (for keep-alive)\n deactivated (new) (for keep-alive)\n ready | deprecated, use mounted (there's no longer the guarantee to be in-document)\nactivate | deprecated, moved into vue-router\nbeforeCompile | deprecated, use created\ncompiled | deprecated, use mounted\nattached | deprecated, use custom in-dom check in other hooks\ndetached | deprecated, same as above\n\n#升级vue-router\n    就我们目前的项目来说，问题主要出现在以下两点：\n    -router.map方法废弃，此类方法统一作为属性加入到构造函数中（见https://github.com/vuejs/vue-router/releases）。\n    -router.start方法废弃，没有在源码或者realease log中发现对应的替代实现。","source":"_posts/vue2-0-e8-b8-a9-e5-9d-91-e4-b9-8b-e6-97-85.md","raw":"---\ntitle: vue2.0踩坑之旅\ntags:\n  - vue2.0\nid: 9\ncategories:\n  - vue\ndate: 2016-08-22 19:13:48\n---\n\n#升级Vue\n##引入Vue\nVue升级2.0，将compiler与runtime 分开，分成两个build，分别是:\n\n-Standalone build: includes both the compiler and the runtime. This functions basically exactly the same Vue 1.x does.\n\n-Runtime only build:since it doesn't include the compiler, you need to either pre-compiled templates in a compile step, or manually written render functions. The npm package will export this build by default, since when consuming Vue from npm, you will likely be using a compilation step (with Browserify or Webpack), during which vueif or vue-loader will perform the template pre-compilation.\n\n默认引入Runtime only build，而我们在不想要改变过去的一系列构建模式的前提下，需要引入Standalone build，路径是'vue/dist/vue.js'(Runtime only build引入的实际上也是dist文件下的文件)\n\n##生命周期钩子\n一定要注意vue2.0对生命周期钩子函数的大量改动：\ninit -> beforeCreate\n created\n beforeDestroy\n destroyed\n beforeMount(new)\n mounte(new)\n beforeUpdate(new)\n updated(new)\n activated (new) (for keep-alive)\n deactivated (new) (for keep-alive)\n ready | deprecated, use mounted (there's no longer the guarantee to be in-document)\nactivate | deprecated, moved into vue-router\nbeforeCompile | deprecated, use created\ncompiled | deprecated, use mounted\nattached | deprecated, use custom in-dom check in other hooks\ndetached | deprecated, same as above\n\n#升级vue-router\n    就我们目前的项目来说，问题主要出现在以下两点：\n    -router.map方法废弃，此类方法统一作为属性加入到构造函数中（见https://github.com/vuejs/vue-router/releases）。\n    -router.start方法废弃，没有在源码或者realease log中发现对应的替代实现。","slug":"vue2-0-e8-b8-a9-e5-9d-91-e4-b9-8b-e6-97-85","published":1,"updated":"2018-10-31T09:05:30.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnwyh59h000eksk34qno8zya","content":"<p>#升级Vue</p>\n<p>##引入Vue<br>Vue升级2.0，将compiler与runtime 分开，分成两个build，分别是:</p>\n<p>-Standalone build: includes both the compiler and the runtime. This functions basically exactly the same Vue 1.x does.</p>\n<p>-Runtime only build:since it doesn’t include the compiler, you need to either pre-compiled templates in a compile step, or manually written render functions. The npm package will export this build by default, since when consuming Vue from npm, you will likely be using a compilation step (with Browserify or Webpack), during which vueif or vue-loader will perform the template pre-compilation.</p>\n<p>默认引入Runtime only build，而我们在不想要改变过去的一系列构建模式的前提下，需要引入Standalone build，路径是’vue/dist/vue.js’(Runtime only build引入的实际上也是dist文件下的文件)</p>\n<p>##生命周期钩子<br>一定要注意vue2.0对生命周期钩子函数的大量改动：<br>init -&gt; beforeCreate<br> created<br> beforeDestroy<br> destroyed<br> beforeMount(new)<br> mounte(new)<br> beforeUpdate(new)<br> updated(new)<br> activated (new) (for keep-alive)<br> deactivated (new) (for keep-alive)<br> ready | deprecated, use mounted (there’s no longer the guarantee to be in-document)<br>activate | deprecated, moved into vue-router<br>beforeCompile | deprecated, use created<br>compiled | deprecated, use mounted<br>attached | deprecated, use custom in-dom check in other hooks<br>detached | deprecated, same as above</p>\n<p>#升级vue-router<br>    就我们目前的项目来说，问题主要出现在以下两点：<br>    -router.map方法废弃，此类方法统一作为属性加入到构造函数中（见<a href=\"https://github.com/vuejs/vue-router/releases）。\" target=\"_blank\" rel=\"noopener\">https://github.com/vuejs/vue-router/releases）。</a><br>    -router.start方法废弃，没有在源码或者realease log中发现对应的替代实现。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#升级Vue</p>\n<p>##引入Vue<br>Vue升级2.0，将compiler与runtime 分开，分成两个build，分别是:</p>\n<p>-Standalone build: includes both the compiler and the runtime. This functions basically exactly the same Vue 1.x does.</p>\n<p>-Runtime only build:since it doesn’t include the compiler, you need to either pre-compiled templates in a compile step, or manually written render functions. The npm package will export this build by default, since when consuming Vue from npm, you will likely be using a compilation step (with Browserify or Webpack), during which vueif or vue-loader will perform the template pre-compilation.</p>\n<p>默认引入Runtime only build，而我们在不想要改变过去的一系列构建模式的前提下，需要引入Standalone build，路径是’vue/dist/vue.js’(Runtime only build引入的实际上也是dist文件下的文件)</p>\n<p>##生命周期钩子<br>一定要注意vue2.0对生命周期钩子函数的大量改动：<br>init -&gt; beforeCreate<br> created<br> beforeDestroy<br> destroyed<br> beforeMount(new)<br> mounte(new)<br> beforeUpdate(new)<br> updated(new)<br> activated (new) (for keep-alive)<br> deactivated (new) (for keep-alive)<br> ready | deprecated, use mounted (there’s no longer the guarantee to be in-document)<br>activate | deprecated, moved into vue-router<br>beforeCompile | deprecated, use created<br>compiled | deprecated, use mounted<br>attached | deprecated, use custom in-dom check in other hooks<br>detached | deprecated, same as above</p>\n<p>#升级vue-router<br>    就我们目前的项目来说，问题主要出现在以下两点：<br>    -router.map方法废弃，此类方法统一作为属性加入到构造函数中（见<a href=\"https://github.com/vuejs/vue-router/releases）。\" target=\"_blank\" rel=\"noopener\">https://github.com/vuejs/vue-router/releases）。</a><br>    -router.start方法废弃，没有在源码或者realease log中发现对应的替代实现。</p>\n"},{"title":"z-index要点","date":"2017-02-07T11:25:06.000Z","_content":"## 理解\n可以理解为\"*版本号*\",即父元素为主版本,子元素为次要版本,由此来确立层叠顺序.\n## 父子\n父子元素下,*只要父元素设置了z-index值,无论子元素如何设置,其都在其父元素之上显示*,但是,如果父元素没有设置,或设置为默认值,当子组件设置z-index为负值时,子组件会放置于父组件之下.\n## 默认值\nz-index的默认值auto的意思为,不新建堆叠上下文,元素所在的堆叠上下文和其父元素相同.\n## 问题\n基于以上规则,子元素作为次要\"版本号\"无法堆叠在其父版本的兄弟版本上时,解决思路有可以通过移除不同级别的菜单之间的重叠，或者使用ID选择器指定独立的（不同的）z-index值，或者减少HTML的层级。","source":"_posts/z-index要点.md","raw":"---\ntitle: z-index要点\ndate: 2017-02-07 19:25:06\ntags:\n---\n## 理解\n可以理解为\"*版本号*\",即父元素为主版本,子元素为次要版本,由此来确立层叠顺序.\n## 父子\n父子元素下,*只要父元素设置了z-index值,无论子元素如何设置,其都在其父元素之上显示*,但是,如果父元素没有设置,或设置为默认值,当子组件设置z-index为负值时,子组件会放置于父组件之下.\n## 默认值\nz-index的默认值auto的意思为,不新建堆叠上下文,元素所在的堆叠上下文和其父元素相同.\n## 问题\n基于以上规则,子元素作为次要\"版本号\"无法堆叠在其父版本的兄弟版本上时,解决思路有可以通过移除不同级别的菜单之间的重叠，或者使用ID选择器指定独立的（不同的）z-index值，或者减少HTML的层级。","slug":"z-index要点","published":1,"updated":"2018-10-31T09:05:30.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnwyh59k000iksk34br3a57t","content":"<h2 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h2><p>可以理解为”<em>版本号</em>“,即父元素为主版本,子元素为次要版本,由此来确立层叠顺序.</p>\n<h2 id=\"父子\"><a href=\"#父子\" class=\"headerlink\" title=\"父子\"></a>父子</h2><p>父子元素下,<em>只要父元素设置了z-index值,无论子元素如何设置,其都在其父元素之上显示</em>,但是,如果父元素没有设置,或设置为默认值,当子组件设置z-index为负值时,子组件会放置于父组件之下.</p>\n<h2 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h2><p>z-index的默认值auto的意思为,不新建堆叠上下文,元素所在的堆叠上下文和其父元素相同.</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>基于以上规则,子元素作为次要”版本号”无法堆叠在其父版本的兄弟版本上时,解决思路有可以通过移除不同级别的菜单之间的重叠，或者使用ID选择器指定独立的（不同的）z-index值，或者减少HTML的层级。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h2><p>可以理解为”<em>版本号</em>“,即父元素为主版本,子元素为次要版本,由此来确立层叠顺序.</p>\n<h2 id=\"父子\"><a href=\"#父子\" class=\"headerlink\" title=\"父子\"></a>父子</h2><p>父子元素下,<em>只要父元素设置了z-index值,无论子元素如何设置,其都在其父元素之上显示</em>,但是,如果父元素没有设置,或设置为默认值,当子组件设置z-index为负值时,子组件会放置于父组件之下.</p>\n<h2 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h2><p>z-index的默认值auto的意思为,不新建堆叠上下文,元素所在的堆叠上下文和其父元素相同.</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>基于以上规则,子元素作为次要”版本号”无法堆叠在其父版本的兄弟版本上时,解决思路有可以通过移除不同级别的菜单之间的重叠，或者使用ID选择器指定独立的（不同的）z-index值，或者减少HTML的层级。</p>\n"},{"title":"事件辨析","date":"2018-03-15T06:14:38.000Z","_content":"# 事件\n## HTML事件处理程序\n即通过与事件处理程序同名的HTML特性来实现.\n`<input type=\"button\" onclick=\"alert('HTML')\">`\n+ 有权访问全局作用域中任意代码.\n+ this值为事件的目标元素.\n+ 作用域扩展至document以及本元素本身,即相当于`with(this)`.\n+ 如果当前元素是一个表单输入元素,作用域扩展至整个表单元素,即相当于`with(this.form)`.\n+ 生成event对象,不必自己定义,亦不必从函数参数列表中获取.\n+ 存在时差问题,当HTML加载时,对应的JavaScript可能没有加载.\n+ 前述提到的作用域扩展在浏览器间行为并不一致.\n+ 可以通过设置当前元素DOM的对应事件处理属性为null的方式销毁事件.\n+ 显然应该在事件到达元素本身的时候处理.\n## DOM0级事件处理程序\nDOM0指第四代浏览器(IE4.0, Netscape4.0)最初支持的DOM规则,并不是事实存在的标准.\n将一个函数赋值给一个事件处理程序属性,首先必须取得一个要操作对象的引用.\n`let btn = document.getElementById('btn');\n btn.onclick = () => {\n    alert('DOM0');\n }`\n+ 简单,跨浏览器兼容.\n+ this引用当前元素.\n+ 在冒泡阶段被处理\n+ 销毁时设置对应属性为null `btn.onclick = null;`\n## DOM2级事件处理程序\naddEventListener removeEventListener\n接受三个参数,要处理的事件名,事件处理函数,布尔值(true,捕获阶段处理事件;false,冒泡阶段处理事件)\n+ this引用当前元素\n+ 按顺序添加的事件按顺序执行\n+ addEventListener添加的事件只能由removeEventListener移除,移除时需参数相同,这意味着匿名事件处理函数将无法移除.\n+ 捕获浏览器兼容性较差\n","source":"_posts/事件辨析.md","raw":"---\ntitle: 事件辨析\ndate: 2018-03-15 14:14:38\ntags:\n    - 事件\n    - HTML\n    - JavaScript\n---\n# 事件\n## HTML事件处理程序\n即通过与事件处理程序同名的HTML特性来实现.\n`<input type=\"button\" onclick=\"alert('HTML')\">`\n+ 有权访问全局作用域中任意代码.\n+ this值为事件的目标元素.\n+ 作用域扩展至document以及本元素本身,即相当于`with(this)`.\n+ 如果当前元素是一个表单输入元素,作用域扩展至整个表单元素,即相当于`with(this.form)`.\n+ 生成event对象,不必自己定义,亦不必从函数参数列表中获取.\n+ 存在时差问题,当HTML加载时,对应的JavaScript可能没有加载.\n+ 前述提到的作用域扩展在浏览器间行为并不一致.\n+ 可以通过设置当前元素DOM的对应事件处理属性为null的方式销毁事件.\n+ 显然应该在事件到达元素本身的时候处理.\n## DOM0级事件处理程序\nDOM0指第四代浏览器(IE4.0, Netscape4.0)最初支持的DOM规则,并不是事实存在的标准.\n将一个函数赋值给一个事件处理程序属性,首先必须取得一个要操作对象的引用.\n`let btn = document.getElementById('btn');\n btn.onclick = () => {\n    alert('DOM0');\n }`\n+ 简单,跨浏览器兼容.\n+ this引用当前元素.\n+ 在冒泡阶段被处理\n+ 销毁时设置对应属性为null `btn.onclick = null;`\n## DOM2级事件处理程序\naddEventListener removeEventListener\n接受三个参数,要处理的事件名,事件处理函数,布尔值(true,捕获阶段处理事件;false,冒泡阶段处理事件)\n+ this引用当前元素\n+ 按顺序添加的事件按顺序执行\n+ addEventListener添加的事件只能由removeEventListener移除,移除时需参数相同,这意味着匿名事件处理函数将无法移除.\n+ 捕获浏览器兼容性较差\n","slug":"事件辨析","published":1,"updated":"2018-10-31T09:05:30.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnwyh59m000jksk37zeara4b","content":"<h1 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h1><h2 id=\"HTML事件处理程序\"><a href=\"#HTML事件处理程序\" class=\"headerlink\" title=\"HTML事件处理程序\"></a>HTML事件处理程序</h2><p>即通过与事件处理程序同名的HTML特性来实现.<br><code>&lt;input type=&quot;button&quot; onclick=&quot;alert(&#39;HTML&#39;)&quot;&gt;</code></p>\n<ul>\n<li>有权访问全局作用域中任意代码.</li>\n<li>this值为事件的目标元素.</li>\n<li>作用域扩展至document以及本元素本身,即相当于<code>with(this)</code>.</li>\n<li>如果当前元素是一个表单输入元素,作用域扩展至整个表单元素,即相当于<code>with(this.form)</code>.</li>\n<li>生成event对象,不必自己定义,亦不必从函数参数列表中获取.</li>\n<li>存在时差问题,当HTML加载时,对应的JavaScript可能没有加载.</li>\n<li>前述提到的作用域扩展在浏览器间行为并不一致.</li>\n<li>可以通过设置当前元素DOM的对应事件处理属性为null的方式销毁事件.</li>\n<li>显然应该在事件到达元素本身的时候处理.<h2 id=\"DOM0级事件处理程序\"><a href=\"#DOM0级事件处理程序\" class=\"headerlink\" title=\"DOM0级事件处理程序\"></a>DOM0级事件处理程序</h2>DOM0指第四代浏览器(IE4.0, Netscape4.0)最初支持的DOM规则,并不是事实存在的标准.<br>将一个函数赋值给一个事件处理程序属性,首先必须取得一个要操作对象的引用.<br><code>let btn = document.getElementById(&#39;btn&#39;);\nbtn.onclick = () =&gt; {\n  alert(&#39;DOM0&#39;);\n}</code></li>\n<li>简单,跨浏览器兼容.</li>\n<li>this引用当前元素.</li>\n<li>在冒泡阶段被处理</li>\n<li>销毁时设置对应属性为null <code>btn.onclick = null;</code><h2 id=\"DOM2级事件处理程序\"><a href=\"#DOM2级事件处理程序\" class=\"headerlink\" title=\"DOM2级事件处理程序\"></a>DOM2级事件处理程序</h2>addEventListener removeEventListener<br>接受三个参数,要处理的事件名,事件处理函数,布尔值(true,捕获阶段处理事件;false,冒泡阶段处理事件)</li>\n<li>this引用当前元素</li>\n<li>按顺序添加的事件按顺序执行</li>\n<li>addEventListener添加的事件只能由removeEventListener移除,移除时需参数相同,这意味着匿名事件处理函数将无法移除.</li>\n<li>捕获浏览器兼容性较差</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h1><h2 id=\"HTML事件处理程序\"><a href=\"#HTML事件处理程序\" class=\"headerlink\" title=\"HTML事件处理程序\"></a>HTML事件处理程序</h2><p>即通过与事件处理程序同名的HTML特性来实现.<br><code>&lt;input type=&quot;button&quot; onclick=&quot;alert(&#39;HTML&#39;)&quot;&gt;</code></p>\n<ul>\n<li>有权访问全局作用域中任意代码.</li>\n<li>this值为事件的目标元素.</li>\n<li>作用域扩展至document以及本元素本身,即相当于<code>with(this)</code>.</li>\n<li>如果当前元素是一个表单输入元素,作用域扩展至整个表单元素,即相当于<code>with(this.form)</code>.</li>\n<li>生成event对象,不必自己定义,亦不必从函数参数列表中获取.</li>\n<li>存在时差问题,当HTML加载时,对应的JavaScript可能没有加载.</li>\n<li>前述提到的作用域扩展在浏览器间行为并不一致.</li>\n<li>可以通过设置当前元素DOM的对应事件处理属性为null的方式销毁事件.</li>\n<li>显然应该在事件到达元素本身的时候处理.<h2 id=\"DOM0级事件处理程序\"><a href=\"#DOM0级事件处理程序\" class=\"headerlink\" title=\"DOM0级事件处理程序\"></a>DOM0级事件处理程序</h2>DOM0指第四代浏览器(IE4.0, Netscape4.0)最初支持的DOM规则,并不是事实存在的标准.<br>将一个函数赋值给一个事件处理程序属性,首先必须取得一个要操作对象的引用.<br><code>let btn = document.getElementById(&#39;btn&#39;);\nbtn.onclick = () =&gt; {\n  alert(&#39;DOM0&#39;);\n}</code></li>\n<li>简单,跨浏览器兼容.</li>\n<li>this引用当前元素.</li>\n<li>在冒泡阶段被处理</li>\n<li>销毁时设置对应属性为null <code>btn.onclick = null;</code><h2 id=\"DOM2级事件处理程序\"><a href=\"#DOM2级事件处理程序\" class=\"headerlink\" title=\"DOM2级事件处理程序\"></a>DOM2级事件处理程序</h2>addEventListener removeEventListener<br>接受三个参数,要处理的事件名,事件处理函数,布尔值(true,捕获阶段处理事件;false,冒泡阶段处理事件)</li>\n<li>this引用当前元素</li>\n<li>按顺序添加的事件按顺序执行</li>\n<li>addEventListener添加的事件只能由removeEventListener移除,移除时需参数相同,这意味着匿名事件处理函数将无法移除.</li>\n<li>捕获浏览器兼容性较差</li>\n</ul>\n"},{"title":"前端错误监控","date":"2018-10-31T09:05:43.000Z","_content":"# 监听内容\n1 静态资源404\n2 异步接口错误的上报\n3 vue error错误上报\n4 promise 捕获\n## 原理\n1.\tvue error 监听\n\t- vue捕获了 vue 运行中产生的错误，故无法直接使用全局错误监听的方式监听此类错误，需使用 vue 提供的errorHandler 接口来实现对错误的监听。\n2. js error及 静态资源错误\n\t- 均使用 addeventlistener 函数在 window 上添加 error 事件监听。\n\t- 对于静态资源错误，不会冒泡，故上述监听函数应使用捕获模式。\n\t- 静态资源的网络相关错误信息（如错误码）无法通过常规方式得到，故需在监听到静态资源错误的时候，对发生错误的链接发送一个 HEAD 的请求，以获取对应的网络相关错误信息。\n\t- HEAD方法跟GET方法相同，只不过服务器响应时不会返回消息体。一个HEAD请求的响应中，HTTP头中包含的元信息应该和一个GET请求的响应消息相同。这种方法可以用来获取请求中隐含的元信息，而不用传输实体本身。也经常用来测试超链接的有效性、可用性和最近的修改。\n3. 异步接口错误\n\t- 重写XMLHttpRequest类的 send 和 open 方法，记录相关请求参数。\n\t- 监听readystatechange事件，当 status 为表示错误的状态码（即大于等于400）时，上报错误\n4. promise 捕获\n    　当我们希望在浏览器上捕获全局错误时会监听 window 对象的 error 事件，可是 error 事件只是捕获错误而已，对于 Promise 的 reject 未处理是不会触发的。如今在业务代码中我们越来越多地使用 Promise，导致很多被放在 Promise 中处理的逻辑错误仅仅是被 reject 没有触发 error。\n　　通过 unhandledrejection 事件，我们就可以捕获未处理的 reject 。\n　　因为 unhandledrejection 事件的接口中不包含 error 相关的信息，故我们无法获取堆栈信息，除非在 reject 的时候入参设置为一个 error 对象（如 ```reject（new Error('error')```）\n\n## 三种错误类型\n### JavaScript错误\n- **即一切跟 JavaScript 相关的错误**，包括\n\t- JavaScript运行时错误\n\t- JavaScript语法错误\n\t- Promise reject 未处理\n\t- vue 运行时错误\n\t- 用户自己抛出的错误。\n- 这些错误的共同特点是有堆栈信息，且堆栈信息有意义。\n### 静态资源错误\n- 即静态资源加载错误，如图片链接404等。\n- 这些错误的共同特点是，有 DOM 信息。\n### AJAX错误\n- 即 AJAX 请求时发生的错误，如服务器返回400，500等。\n- 这些错误的共同特点不言而喻，都是 AJAX 请求。\n- 后续考虑升级成对 HTTP 请求的监听\n\n## 压缩\n使用lz-string\n### 压缩效率\n**原大小的35.63%，减少了64.37%**\n#### 压缩方式\n**gzip**\n#### gzip与deflate对比\ngzip的基础是DEFLATE，DEFLATE是LZ77与哈夫曼编码的一个组合体，二者区别主要有：\n1. 两者都是使用Gzip压缩算法\n2. deflate压缩速度略快，gzip压缩比略高。默认情况下，gzip会比deflate多压4%-6%\n3. gzip对CPU占用要高一些，deflate是专门为保护性能的压缩模块，它仅需很小的资源来压缩文件\n综上，我们更关注压缩比，故选择 gzip\n\n## 错误合并逻辑\n### javascriptError\n所在文件 类型 信息共5个因素一致即为同一错误\n### httpError\n url status statusText 3个因素一致即为同一错误\n### resourceError\nurl status statusText xpath 四个因素一致即为同一错误\n","source":"_posts/前端错误监控.md","raw":"---\ntitle: 前端错误监控\ndate: 2018-10-31 17:05:43\ntags:\n    - 错误监控\n    - JavaScript\n    - vue\n---\n# 监听内容\n1 静态资源404\n2 异步接口错误的上报\n3 vue error错误上报\n4 promise 捕获\n## 原理\n1.\tvue error 监听\n\t- vue捕获了 vue 运行中产生的错误，故无法直接使用全局错误监听的方式监听此类错误，需使用 vue 提供的errorHandler 接口来实现对错误的监听。\n2. js error及 静态资源错误\n\t- 均使用 addeventlistener 函数在 window 上添加 error 事件监听。\n\t- 对于静态资源错误，不会冒泡，故上述监听函数应使用捕获模式。\n\t- 静态资源的网络相关错误信息（如错误码）无法通过常规方式得到，故需在监听到静态资源错误的时候，对发生错误的链接发送一个 HEAD 的请求，以获取对应的网络相关错误信息。\n\t- HEAD方法跟GET方法相同，只不过服务器响应时不会返回消息体。一个HEAD请求的响应中，HTTP头中包含的元信息应该和一个GET请求的响应消息相同。这种方法可以用来获取请求中隐含的元信息，而不用传输实体本身。也经常用来测试超链接的有效性、可用性和最近的修改。\n3. 异步接口错误\n\t- 重写XMLHttpRequest类的 send 和 open 方法，记录相关请求参数。\n\t- 监听readystatechange事件，当 status 为表示错误的状态码（即大于等于400）时，上报错误\n4. promise 捕获\n    　当我们希望在浏览器上捕获全局错误时会监听 window 对象的 error 事件，可是 error 事件只是捕获错误而已，对于 Promise 的 reject 未处理是不会触发的。如今在业务代码中我们越来越多地使用 Promise，导致很多被放在 Promise 中处理的逻辑错误仅仅是被 reject 没有触发 error。\n　　通过 unhandledrejection 事件，我们就可以捕获未处理的 reject 。\n　　因为 unhandledrejection 事件的接口中不包含 error 相关的信息，故我们无法获取堆栈信息，除非在 reject 的时候入参设置为一个 error 对象（如 ```reject（new Error('error')```）\n\n## 三种错误类型\n### JavaScript错误\n- **即一切跟 JavaScript 相关的错误**，包括\n\t- JavaScript运行时错误\n\t- JavaScript语法错误\n\t- Promise reject 未处理\n\t- vue 运行时错误\n\t- 用户自己抛出的错误。\n- 这些错误的共同特点是有堆栈信息，且堆栈信息有意义。\n### 静态资源错误\n- 即静态资源加载错误，如图片链接404等。\n- 这些错误的共同特点是，有 DOM 信息。\n### AJAX错误\n- 即 AJAX 请求时发生的错误，如服务器返回400，500等。\n- 这些错误的共同特点不言而喻，都是 AJAX 请求。\n- 后续考虑升级成对 HTTP 请求的监听\n\n## 压缩\n使用lz-string\n### 压缩效率\n**原大小的35.63%，减少了64.37%**\n#### 压缩方式\n**gzip**\n#### gzip与deflate对比\ngzip的基础是DEFLATE，DEFLATE是LZ77与哈夫曼编码的一个组合体，二者区别主要有：\n1. 两者都是使用Gzip压缩算法\n2. deflate压缩速度略快，gzip压缩比略高。默认情况下，gzip会比deflate多压4%-6%\n3. gzip对CPU占用要高一些，deflate是专门为保护性能的压缩模块，它仅需很小的资源来压缩文件\n综上，我们更关注压缩比，故选择 gzip\n\n## 错误合并逻辑\n### javascriptError\n所在文件 类型 信息共5个因素一致即为同一错误\n### httpError\n url status statusText 3个因素一致即为同一错误\n### resourceError\nurl status statusText xpath 四个因素一致即为同一错误\n","slug":"前端错误监控","published":1,"updated":"2018-10-31T09:25:28.985Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnwyh59n000mksk32i7dt1p9","content":"<h1 id=\"监听内容\"><a href=\"#监听内容\" class=\"headerlink\" title=\"监听内容\"></a>监听内容</h1><p>1 静态资源404<br>2 异步接口错误的上报<br>3 vue error错误上报<br>4 promise 捕获</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><ol>\n<li>vue error 监听<ul>\n<li>vue捕获了 vue 运行中产生的错误，故无法直接使用全局错误监听的方式监听此类错误，需使用 vue 提供的errorHandler 接口来实现对错误的监听。</li>\n</ul>\n</li>\n<li>js error及 静态资源错误<ul>\n<li>均使用 addeventlistener 函数在 window 上添加 error 事件监听。</li>\n<li>对于静态资源错误，不会冒泡，故上述监听函数应使用捕获模式。</li>\n<li>静态资源的网络相关错误信息（如错误码）无法通过常规方式得到，故需在监听到静态资源错误的时候，对发生错误的链接发送一个 HEAD 的请求，以获取对应的网络相关错误信息。</li>\n<li>HEAD方法跟GET方法相同，只不过服务器响应时不会返回消息体。一个HEAD请求的响应中，HTTP头中包含的元信息应该和一个GET请求的响应消息相同。这种方法可以用来获取请求中隐含的元信息，而不用传输实体本身。也经常用来测试超链接的有效性、可用性和最近的修改。</li>\n</ul>\n</li>\n<li>异步接口错误<ul>\n<li>重写XMLHttpRequest类的 send 和 open 方法，记录相关请求参数。</li>\n<li>监听readystatechange事件，当 status 为表示错误的状态码（即大于等于400）时，上报错误</li>\n</ul>\n</li>\n<li>promise 捕获<br> 　当我们希望在浏览器上捕获全局错误时会监听 window 对象的 error 事件，可是 error 事件只是捕获错误而已，对于 Promise 的 reject 未处理是不会触发的。如今在业务代码中我们越来越多地使用 Promise，导致很多被放在 Promise 中处理的逻辑错误仅仅是被 reject 没有触发 error。<br>　　通过 unhandledrejection 事件，我们就可以捕获未处理的 reject 。<br>　　因为 unhandledrejection 事件的接口中不包含 error 相关的信息，故我们无法获取堆栈信息，除非在 reject 的时候入参设置为一个 error 对象（如 <code>reject（new Error(&#39;error&#39;)</code>）</li>\n</ol>\n<h2 id=\"三种错误类型\"><a href=\"#三种错误类型\" class=\"headerlink\" title=\"三种错误类型\"></a>三种错误类型</h2><h3 id=\"JavaScript错误\"><a href=\"#JavaScript错误\" class=\"headerlink\" title=\"JavaScript错误\"></a>JavaScript错误</h3><ul>\n<li><strong>即一切跟 JavaScript 相关的错误</strong>，包括<ul>\n<li>JavaScript运行时错误</li>\n<li>JavaScript语法错误</li>\n<li>Promise reject 未处理</li>\n<li>vue 运行时错误</li>\n<li>用户自己抛出的错误。</li>\n</ul>\n</li>\n<li>这些错误的共同特点是有堆栈信息，且堆栈信息有意义。<h3 id=\"静态资源错误\"><a href=\"#静态资源错误\" class=\"headerlink\" title=\"静态资源错误\"></a>静态资源错误</h3></li>\n<li>即静态资源加载错误，如图片链接404等。</li>\n<li>这些错误的共同特点是，有 DOM 信息。<h3 id=\"AJAX错误\"><a href=\"#AJAX错误\" class=\"headerlink\" title=\"AJAX错误\"></a>AJAX错误</h3></li>\n<li>即 AJAX 请求时发生的错误，如服务器返回400，500等。</li>\n<li>这些错误的共同特点不言而喻，都是 AJAX 请求。</li>\n<li>后续考虑升级成对 HTTP 请求的监听</li>\n</ul>\n<h2 id=\"压缩\"><a href=\"#压缩\" class=\"headerlink\" title=\"压缩\"></a>压缩</h2><p>使用lz-string</p>\n<h3 id=\"压缩效率\"><a href=\"#压缩效率\" class=\"headerlink\" title=\"压缩效率\"></a>压缩效率</h3><p><strong>原大小的35.63%，减少了64.37%</strong></p>\n<h4 id=\"压缩方式\"><a href=\"#压缩方式\" class=\"headerlink\" title=\"压缩方式\"></a>压缩方式</h4><p><strong>gzip</strong></p>\n<h4 id=\"gzip与deflate对比\"><a href=\"#gzip与deflate对比\" class=\"headerlink\" title=\"gzip与deflate对比\"></a>gzip与deflate对比</h4><p>gzip的基础是DEFLATE，DEFLATE是LZ77与哈夫曼编码的一个组合体，二者区别主要有：</p>\n<ol>\n<li>两者都是使用Gzip压缩算法</li>\n<li>deflate压缩速度略快，gzip压缩比略高。默认情况下，gzip会比deflate多压4%-6%</li>\n<li>gzip对CPU占用要高一些，deflate是专门为保护性能的压缩模块，它仅需很小的资源来压缩文件<br>综上，我们更关注压缩比，故选择 gzip</li>\n</ol>\n<h2 id=\"错误合并逻辑\"><a href=\"#错误合并逻辑\" class=\"headerlink\" title=\"错误合并逻辑\"></a>错误合并逻辑</h2><h3 id=\"javascriptError\"><a href=\"#javascriptError\" class=\"headerlink\" title=\"javascriptError\"></a>javascriptError</h3><p>所在文件 类型 信息共5个因素一致即为同一错误</p>\n<h3 id=\"httpError\"><a href=\"#httpError\" class=\"headerlink\" title=\"httpError\"></a>httpError</h3><p> url status statusText 3个因素一致即为同一错误</p>\n<h3 id=\"resourceError\"><a href=\"#resourceError\" class=\"headerlink\" title=\"resourceError\"></a>resourceError</h3><p>url status statusText xpath 四个因素一致即为同一错误</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"监听内容\"><a href=\"#监听内容\" class=\"headerlink\" title=\"监听内容\"></a>监听内容</h1><p>1 静态资源404<br>2 异步接口错误的上报<br>3 vue error错误上报<br>4 promise 捕获</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><ol>\n<li>vue error 监听<ul>\n<li>vue捕获了 vue 运行中产生的错误，故无法直接使用全局错误监听的方式监听此类错误，需使用 vue 提供的errorHandler 接口来实现对错误的监听。</li>\n</ul>\n</li>\n<li>js error及 静态资源错误<ul>\n<li>均使用 addeventlistener 函数在 window 上添加 error 事件监听。</li>\n<li>对于静态资源错误，不会冒泡，故上述监听函数应使用捕获模式。</li>\n<li>静态资源的网络相关错误信息（如错误码）无法通过常规方式得到，故需在监听到静态资源错误的时候，对发生错误的链接发送一个 HEAD 的请求，以获取对应的网络相关错误信息。</li>\n<li>HEAD方法跟GET方法相同，只不过服务器响应时不会返回消息体。一个HEAD请求的响应中，HTTP头中包含的元信息应该和一个GET请求的响应消息相同。这种方法可以用来获取请求中隐含的元信息，而不用传输实体本身。也经常用来测试超链接的有效性、可用性和最近的修改。</li>\n</ul>\n</li>\n<li>异步接口错误<ul>\n<li>重写XMLHttpRequest类的 send 和 open 方法，记录相关请求参数。</li>\n<li>监听readystatechange事件，当 status 为表示错误的状态码（即大于等于400）时，上报错误</li>\n</ul>\n</li>\n<li>promise 捕获<br> 　当我们希望在浏览器上捕获全局错误时会监听 window 对象的 error 事件，可是 error 事件只是捕获错误而已，对于 Promise 的 reject 未处理是不会触发的。如今在业务代码中我们越来越多地使用 Promise，导致很多被放在 Promise 中处理的逻辑错误仅仅是被 reject 没有触发 error。<br>　　通过 unhandledrejection 事件，我们就可以捕获未处理的 reject 。<br>　　因为 unhandledrejection 事件的接口中不包含 error 相关的信息，故我们无法获取堆栈信息，除非在 reject 的时候入参设置为一个 error 对象（如 <code>reject（new Error(&#39;error&#39;)</code>）</li>\n</ol>\n<h2 id=\"三种错误类型\"><a href=\"#三种错误类型\" class=\"headerlink\" title=\"三种错误类型\"></a>三种错误类型</h2><h3 id=\"JavaScript错误\"><a href=\"#JavaScript错误\" class=\"headerlink\" title=\"JavaScript错误\"></a>JavaScript错误</h3><ul>\n<li><strong>即一切跟 JavaScript 相关的错误</strong>，包括<ul>\n<li>JavaScript运行时错误</li>\n<li>JavaScript语法错误</li>\n<li>Promise reject 未处理</li>\n<li>vue 运行时错误</li>\n<li>用户自己抛出的错误。</li>\n</ul>\n</li>\n<li>这些错误的共同特点是有堆栈信息，且堆栈信息有意义。<h3 id=\"静态资源错误\"><a href=\"#静态资源错误\" class=\"headerlink\" title=\"静态资源错误\"></a>静态资源错误</h3></li>\n<li>即静态资源加载错误，如图片链接404等。</li>\n<li>这些错误的共同特点是，有 DOM 信息。<h3 id=\"AJAX错误\"><a href=\"#AJAX错误\" class=\"headerlink\" title=\"AJAX错误\"></a>AJAX错误</h3></li>\n<li>即 AJAX 请求时发生的错误，如服务器返回400，500等。</li>\n<li>这些错误的共同特点不言而喻，都是 AJAX 请求。</li>\n<li>后续考虑升级成对 HTTP 请求的监听</li>\n</ul>\n<h2 id=\"压缩\"><a href=\"#压缩\" class=\"headerlink\" title=\"压缩\"></a>压缩</h2><p>使用lz-string</p>\n<h3 id=\"压缩效率\"><a href=\"#压缩效率\" class=\"headerlink\" title=\"压缩效率\"></a>压缩效率</h3><p><strong>原大小的35.63%，减少了64.37%</strong></p>\n<h4 id=\"压缩方式\"><a href=\"#压缩方式\" class=\"headerlink\" title=\"压缩方式\"></a>压缩方式</h4><p><strong>gzip</strong></p>\n<h4 id=\"gzip与deflate对比\"><a href=\"#gzip与deflate对比\" class=\"headerlink\" title=\"gzip与deflate对比\"></a>gzip与deflate对比</h4><p>gzip的基础是DEFLATE，DEFLATE是LZ77与哈夫曼编码的一个组合体，二者区别主要有：</p>\n<ol>\n<li>两者都是使用Gzip压缩算法</li>\n<li>deflate压缩速度略快，gzip压缩比略高。默认情况下，gzip会比deflate多压4%-6%</li>\n<li>gzip对CPU占用要高一些，deflate是专门为保护性能的压缩模块，它仅需很小的资源来压缩文件<br>综上，我们更关注压缩比，故选择 gzip</li>\n</ol>\n<h2 id=\"错误合并逻辑\"><a href=\"#错误合并逻辑\" class=\"headerlink\" title=\"错误合并逻辑\"></a>错误合并逻辑</h2><h3 id=\"javascriptError\"><a href=\"#javascriptError\" class=\"headerlink\" title=\"javascriptError\"></a>javascriptError</h3><p>所在文件 类型 信息共5个因素一致即为同一错误</p>\n<h3 id=\"httpError\"><a href=\"#httpError\" class=\"headerlink\" title=\"httpError\"></a>httpError</h3><p> url status statusText 3个因素一致即为同一错误</p>\n<h3 id=\"resourceError\"><a href=\"#resourceError\" class=\"headerlink\" title=\"resourceError\"></a>resourceError</h3><p>url status statusText xpath 四个因素一致即为同一错误</p>\n"},{"title":"《你不知道的JavaScript》(上卷)读书笔记","date":"2018-03-15T06:12:32.000Z","_content":"# 《你不知道的JavaScript》(上卷)读书笔记\n## 第一部分\n### 语言\n事实上,JavaScript是一门编译语言,但与传统的编译语言不同,他不是提前编译的,编译结果也不能在分布式系统中进行移植.\n\nJavaScript引擎进行编译的步骤与传统语言非常相似,包括分词/词法分析,解析/语法分析,代码生成.\n\n比起那些编译过程只有三个步骤的语言的编译器,JavaScript在语法分析和代码生成阶段有特定的步骤对运行性能进行优化,包括对冗余元素进行优化等\n\n### LHS与RHS\n- LHS:左值查询,试图找到变量的容器本身,从而可以对其赋值.\n- RHS:右值查询,与简单地查找某个变量的值别无二致.\n- 从概念上讲,LHS查找赋值的目标,RHS查找赋值的源头.\n### 词法作用域\n是定义在词法阶段的作用域,换句话说,是由你在写代码时将变量和块作用域写在哪里决定的,区别于动态作用域.\n#### 欺骗词法作用域\n##### eval\n- 接受一个字符串为参数,并将其中的内容视为好像在书写时就存在于程序中的这个位置的代码.\n- 严格模式下,eval有自己的词法作用域.\n- JavaScript中还有一些类似的功能效果,例如setTimeout以及setInterval第一个参数(本质上还是调用了eval),以及new Function的最后一个参数.\n##### with\n- 尽管with块可以将一个对象处理为词法作用域,但是这个块内部正常的var声明比并不会被限制在这个块的作用域中,而是被添加到with所处的函数作用域中.\n- 严格模式下被禁用了.\n##### 性能问题\n编译阶段的很多优化没法做了.\n### 函数作用域\n#### 函数声明与函数表达式\n区分函数声明和表达式最简单的方法是看function关键字出现在生命中的位置。如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。\n#### 匿名与具名\n始终给函数表达式命名是一个最佳实践。\n## 未完待续","source":"_posts/《你不知道的JavaScript》-上卷-读书笔记.md","raw":"---\ntitle: 《你不知道的JavaScript》(上卷)读书笔记\ndate: 2018-03-15 14:12:32\ntags:\n    - 你不知道的JavaScript\n    - JavaScript\n    - 读书笔记\n---\n# 《你不知道的JavaScript》(上卷)读书笔记\n## 第一部分\n### 语言\n事实上,JavaScript是一门编译语言,但与传统的编译语言不同,他不是提前编译的,编译结果也不能在分布式系统中进行移植.\n\nJavaScript引擎进行编译的步骤与传统语言非常相似,包括分词/词法分析,解析/语法分析,代码生成.\n\n比起那些编译过程只有三个步骤的语言的编译器,JavaScript在语法分析和代码生成阶段有特定的步骤对运行性能进行优化,包括对冗余元素进行优化等\n\n### LHS与RHS\n- LHS:左值查询,试图找到变量的容器本身,从而可以对其赋值.\n- RHS:右值查询,与简单地查找某个变量的值别无二致.\n- 从概念上讲,LHS查找赋值的目标,RHS查找赋值的源头.\n### 词法作用域\n是定义在词法阶段的作用域,换句话说,是由你在写代码时将变量和块作用域写在哪里决定的,区别于动态作用域.\n#### 欺骗词法作用域\n##### eval\n- 接受一个字符串为参数,并将其中的内容视为好像在书写时就存在于程序中的这个位置的代码.\n- 严格模式下,eval有自己的词法作用域.\n- JavaScript中还有一些类似的功能效果,例如setTimeout以及setInterval第一个参数(本质上还是调用了eval),以及new Function的最后一个参数.\n##### with\n- 尽管with块可以将一个对象处理为词法作用域,但是这个块内部正常的var声明比并不会被限制在这个块的作用域中,而是被添加到with所处的函数作用域中.\n- 严格模式下被禁用了.\n##### 性能问题\n编译阶段的很多优化没法做了.\n### 函数作用域\n#### 函数声明与函数表达式\n区分函数声明和表达式最简单的方法是看function关键字出现在生命中的位置。如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。\n#### 匿名与具名\n始终给函数表达式命名是一个最佳实践。\n## 未完待续","slug":"《你不知道的JavaScript》-上卷-读书笔记","published":1,"updated":"2018-10-31T09:05:30.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnwyh59q000pksk3hkrv426t","content":"<h1 id=\"《你不知道的JavaScript》-上卷-读书笔记\"><a href=\"#《你不知道的JavaScript》-上卷-读书笔记\" class=\"headerlink\" title=\"《你不知道的JavaScript》(上卷)读书笔记\"></a>《你不知道的JavaScript》(上卷)读书笔记</h1><h2 id=\"第一部分\"><a href=\"#第一部分\" class=\"headerlink\" title=\"第一部分\"></a>第一部分</h2><h3 id=\"语言\"><a href=\"#语言\" class=\"headerlink\" title=\"语言\"></a>语言</h3><p>事实上,JavaScript是一门编译语言,但与传统的编译语言不同,他不是提前编译的,编译结果也不能在分布式系统中进行移植.</p>\n<p>JavaScript引擎进行编译的步骤与传统语言非常相似,包括分词/词法分析,解析/语法分析,代码生成.</p>\n<p>比起那些编译过程只有三个步骤的语言的编译器,JavaScript在语法分析和代码生成阶段有特定的步骤对运行性能进行优化,包括对冗余元素进行优化等</p>\n<h3 id=\"LHS与RHS\"><a href=\"#LHS与RHS\" class=\"headerlink\" title=\"LHS与RHS\"></a>LHS与RHS</h3><ul>\n<li>LHS:左值查询,试图找到变量的容器本身,从而可以对其赋值.</li>\n<li>RHS:右值查询,与简单地查找某个变量的值别无二致.</li>\n<li>从概念上讲,LHS查找赋值的目标,RHS查找赋值的源头.<h3 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h3>是定义在词法阶段的作用域,换句话说,是由你在写代码时将变量和块作用域写在哪里决定的,区别于动态作用域.<h4 id=\"欺骗词法作用域\"><a href=\"#欺骗词法作用域\" class=\"headerlink\" title=\"欺骗词法作用域\"></a>欺骗词法作用域</h4><h5 id=\"eval\"><a href=\"#eval\" class=\"headerlink\" title=\"eval\"></a>eval</h5></li>\n<li>接受一个字符串为参数,并将其中的内容视为好像在书写时就存在于程序中的这个位置的代码.</li>\n<li>严格模式下,eval有自己的词法作用域.</li>\n<li>JavaScript中还有一些类似的功能效果,例如setTimeout以及setInterval第一个参数(本质上还是调用了eval),以及new Function的最后一个参数.<h5 id=\"with\"><a href=\"#with\" class=\"headerlink\" title=\"with\"></a>with</h5></li>\n<li>尽管with块可以将一个对象处理为词法作用域,但是这个块内部正常的var声明比并不会被限制在这个块的作用域中,而是被添加到with所处的函数作用域中.</li>\n<li>严格模式下被禁用了.<h5 id=\"性能问题\"><a href=\"#性能问题\" class=\"headerlink\" title=\"性能问题\"></a>性能问题</h5>编译阶段的很多优化没法做了.<h3 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h3><h4 id=\"函数声明与函数表达式\"><a href=\"#函数声明与函数表达式\" class=\"headerlink\" title=\"函数声明与函数表达式\"></a>函数声明与函数表达式</h4>区分函数声明和表达式最简单的方法是看function关键字出现在生命中的位置。如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。<h4 id=\"匿名与具名\"><a href=\"#匿名与具名\" class=\"headerlink\" title=\"匿名与具名\"></a>匿名与具名</h4>始终给函数表达式命名是一个最佳实践。<h2 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h2></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"《你不知道的JavaScript》-上卷-读书笔记\"><a href=\"#《你不知道的JavaScript》-上卷-读书笔记\" class=\"headerlink\" title=\"《你不知道的JavaScript》(上卷)读书笔记\"></a>《你不知道的JavaScript》(上卷)读书笔记</h1><h2 id=\"第一部分\"><a href=\"#第一部分\" class=\"headerlink\" title=\"第一部分\"></a>第一部分</h2><h3 id=\"语言\"><a href=\"#语言\" class=\"headerlink\" title=\"语言\"></a>语言</h3><p>事实上,JavaScript是一门编译语言,但与传统的编译语言不同,他不是提前编译的,编译结果也不能在分布式系统中进行移植.</p>\n<p>JavaScript引擎进行编译的步骤与传统语言非常相似,包括分词/词法分析,解析/语法分析,代码生成.</p>\n<p>比起那些编译过程只有三个步骤的语言的编译器,JavaScript在语法分析和代码生成阶段有特定的步骤对运行性能进行优化,包括对冗余元素进行优化等</p>\n<h3 id=\"LHS与RHS\"><a href=\"#LHS与RHS\" class=\"headerlink\" title=\"LHS与RHS\"></a>LHS与RHS</h3><ul>\n<li>LHS:左值查询,试图找到变量的容器本身,从而可以对其赋值.</li>\n<li>RHS:右值查询,与简单地查找某个变量的值别无二致.</li>\n<li>从概念上讲,LHS查找赋值的目标,RHS查找赋值的源头.<h3 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h3>是定义在词法阶段的作用域,换句话说,是由你在写代码时将变量和块作用域写在哪里决定的,区别于动态作用域.<h4 id=\"欺骗词法作用域\"><a href=\"#欺骗词法作用域\" class=\"headerlink\" title=\"欺骗词法作用域\"></a>欺骗词法作用域</h4><h5 id=\"eval\"><a href=\"#eval\" class=\"headerlink\" title=\"eval\"></a>eval</h5></li>\n<li>接受一个字符串为参数,并将其中的内容视为好像在书写时就存在于程序中的这个位置的代码.</li>\n<li>严格模式下,eval有自己的词法作用域.</li>\n<li>JavaScript中还有一些类似的功能效果,例如setTimeout以及setInterval第一个参数(本质上还是调用了eval),以及new Function的最后一个参数.<h5 id=\"with\"><a href=\"#with\" class=\"headerlink\" title=\"with\"></a>with</h5></li>\n<li>尽管with块可以将一个对象处理为词法作用域,但是这个块内部正常的var声明比并不会被限制在这个块的作用域中,而是被添加到with所处的函数作用域中.</li>\n<li>严格模式下被禁用了.<h5 id=\"性能问题\"><a href=\"#性能问题\" class=\"headerlink\" title=\"性能问题\"></a>性能问题</h5>编译阶段的很多优化没法做了.<h3 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h3><h4 id=\"函数声明与函数表达式\"><a href=\"#函数声明与函数表达式\" class=\"headerlink\" title=\"函数声明与函数表达式\"></a>函数声明与函数表达式</h4>区分函数声明和表达式最简单的方法是看function关键字出现在生命中的位置。如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。<h4 id=\"匿名与具名\"><a href=\"#匿名与具名\" class=\"headerlink\" title=\"匿名与具名\"></a>匿名与具名</h4>始终给函数表达式命名是一个最佳实践。<h2 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h2></li>\n</ul>\n"},{"title":"电子书爬虫app","date":"2016-10-07T15:38:56.000Z","_content":"一个爬取市面上主流电子书购买渠道上电子书*价格*的app\n名字还没想好...起名困难症\n逻辑如下:\n1. 搜索一个默认会返回无结果的词,现在是\"______\",记录*主要*DOM结构(以下简称结构,此结果简称空白结果).\n2. 搜索需要的书名\n\t* 如果结构与空白结果相同,则无此电子书出售,结束.\n\t* 反之,进入第三步.\n3. 检索页面中含\"¥\"的第一个DOM标签,同时,当结果为多个时,应给出警告;提取距离该DOM标签最为接近的数字,进入比对集进行比对.\n4. 打开比对集中最小值对应的app或网页\n\n代码在[这里](https://github.com/YXDay/e-bookCarwler)","source":"_posts/电子书爬虫.md","raw":"---\ntitle: 电子书爬虫app\ndate: 2016-10-07 23:38:56\ntags:\n\t- 爬虫\n\t- Node.js\n\t- 电子书\n\t- 版权\n---\n一个爬取市面上主流电子书购买渠道上电子书*价格*的app\n名字还没想好...起名困难症\n逻辑如下:\n1. 搜索一个默认会返回无结果的词,现在是\"______\",记录*主要*DOM结构(以下简称结构,此结果简称空白结果).\n2. 搜索需要的书名\n\t* 如果结构与空白结果相同,则无此电子书出售,结束.\n\t* 反之,进入第三步.\n3. 检索页面中含\"¥\"的第一个DOM标签,同时,当结果为多个时,应给出警告;提取距离该DOM标签最为接近的数字,进入比对集进行比对.\n4. 打开比对集中最小值对应的app或网页\n\n代码在[这里](https://github.com/YXDay/e-bookCarwler)","slug":"电子书爬虫","published":1,"updated":"2018-10-31T09:05:30.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnwyh59s000rksk3fgsy4gho","content":"<p>一个爬取市面上主流电子书购买渠道上电子书<em>价格</em>的app<br>名字还没想好…起名困难症<br>逻辑如下:</p>\n<ol>\n<li>搜索一个默认会返回无结果的词,现在是”<strong>__</strong>“,记录<em>主要</em>DOM结构(以下简称结构,此结果简称空白结果).</li>\n<li>搜索需要的书名<ul>\n<li>如果结构与空白结果相同,则无此电子书出售,结束.</li>\n<li>反之,进入第三步.</li>\n</ul>\n</li>\n<li>检索页面中含”¥”的第一个DOM标签,同时,当结果为多个时,应给出警告;提取距离该DOM标签最为接近的数字,进入比对集进行比对.</li>\n<li>打开比对集中最小值对应的app或网页</li>\n</ol>\n<p>代码在<a href=\"https://github.com/YXDay/e-bookCarwler\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>一个爬取市面上主流电子书购买渠道上电子书<em>价格</em>的app<br>名字还没想好…起名困难症<br>逻辑如下:</p>\n<ol>\n<li>搜索一个默认会返回无结果的词,现在是”<strong>__</strong>“,记录<em>主要</em>DOM结构(以下简称结构,此结果简称空白结果).</li>\n<li>搜索需要的书名<ul>\n<li>如果结构与空白结果相同,则无此电子书出售,结束.</li>\n<li>反之,进入第三步.</li>\n</ul>\n</li>\n<li>检索页面中含”¥”的第一个DOM标签,同时,当结果为多个时,应给出警告;提取距离该DOM标签最为接近的数字,进入比对集进行比对.</li>\n<li>打开比对集中最小值对应的app或网页</li>\n</ol>\n<p>代码在<a href=\"https://github.com/YXDay/e-bookCarwler\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n"},{"title":"复盘-fix不同node_modules引起的bug","date":"2018-03-15T06:16:04.000Z","_content":"# 复盘-fix不同node_modules引起的bug\n一份代码,线上的node_modules包是已有的,线下的node_modules包是我近期通过package.json自行yarn得来的.\n当我把线下的node_modules包替换到线上时,线上报错,此时线下正常.\n顺着错误信息一番debug,乱七八糟的代码使人眼晕,也查不出什么所以然.\n此时冷静分析一下:同一份代码,线下正常,线上出错,二者有何区别?\n- 环境\n- 构建方式\n环境不去说他,小概率事件,构建方式有何不同呢,线下是develop构建,而线上是deploy,\n二者的差别是,deploy的gulp流程多了rev,compress两个步骤,分而治之,证明是compress出了问题.\ncompress中的流程继续分而治之,是gulp-uglify这个包除了问题,对比一下,果然,旧的node_modules里gulp-uglify版本为2.0.0,新的为2.1.2,替换之,遂解决.\n具体的原因日后再更新.\n\n","source":"_posts/复盘-fix不同node-modules引起的bug.md","raw":"---\ntitle: 复盘-fix不同node_modules引起的bug\ndate: 2018-03-15 14:16:04\ntags:\n    - 复盘\n    - 编译\n    - node_modules\n    - bug\n---\n# 复盘-fix不同node_modules引起的bug\n一份代码,线上的node_modules包是已有的,线下的node_modules包是我近期通过package.json自行yarn得来的.\n当我把线下的node_modules包替换到线上时,线上报错,此时线下正常.\n顺着错误信息一番debug,乱七八糟的代码使人眼晕,也查不出什么所以然.\n此时冷静分析一下:同一份代码,线下正常,线上出错,二者有何区别?\n- 环境\n- 构建方式\n环境不去说他,小概率事件,构建方式有何不同呢,线下是develop构建,而线上是deploy,\n二者的差别是,deploy的gulp流程多了rev,compress两个步骤,分而治之,证明是compress出了问题.\ncompress中的流程继续分而治之,是gulp-uglify这个包除了问题,对比一下,果然,旧的node_modules里gulp-uglify版本为2.0.0,新的为2.1.2,替换之,遂解决.\n具体的原因日后再更新.\n\n","slug":"复盘-fix不同node-modules引起的bug","published":1,"updated":"2018-10-31T09:05:30.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnwyh59t000vksk3si0n41pl","content":"<h1 id=\"复盘-fix不同node-modules引起的bug\"><a href=\"#复盘-fix不同node-modules引起的bug\" class=\"headerlink\" title=\"复盘-fix不同node_modules引起的bug\"></a>复盘-fix不同node_modules引起的bug</h1><p>一份代码,线上的node_modules包是已有的,线下的node_modules包是我近期通过package.json自行yarn得来的.<br>当我把线下的node_modules包替换到线上时,线上报错,此时线下正常.<br>顺着错误信息一番debug,乱七八糟的代码使人眼晕,也查不出什么所以然.<br>此时冷静分析一下:同一份代码,线下正常,线上出错,二者有何区别?</p>\n<ul>\n<li>环境</li>\n<li>构建方式<br>环境不去说他,小概率事件,构建方式有何不同呢,线下是develop构建,而线上是deploy,<br>二者的差别是,deploy的gulp流程多了rev,compress两个步骤,分而治之,证明是compress出了问题.<br>compress中的流程继续分而治之,是gulp-uglify这个包除了问题,对比一下,果然,旧的node_modules里gulp-uglify版本为2.0.0,新的为2.1.2,替换之,遂解决.<br>具体的原因日后再更新.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"复盘-fix不同node-modules引起的bug\"><a href=\"#复盘-fix不同node-modules引起的bug\" class=\"headerlink\" title=\"复盘-fix不同node_modules引起的bug\"></a>复盘-fix不同node_modules引起的bug</h1><p>一份代码,线上的node_modules包是已有的,线下的node_modules包是我近期通过package.json自行yarn得来的.<br>当我把线下的node_modules包替换到线上时,线上报错,此时线下正常.<br>顺着错误信息一番debug,乱七八糟的代码使人眼晕,也查不出什么所以然.<br>此时冷静分析一下:同一份代码,线下正常,线上出错,二者有何区别?</p>\n<ul>\n<li>环境</li>\n<li>构建方式<br>环境不去说他,小概率事件,构建方式有何不同呢,线下是develop构建,而线上是deploy,<br>二者的差别是,deploy的gulp流程多了rev,compress两个步骤,分而治之,证明是compress出了问题.<br>compress中的流程继续分而治之,是gulp-uglify这个包除了问题,对比一下,果然,旧的node_modules里gulp-uglify版本为2.0.0,新的为2.1.2,替换之,遂解决.<br>具体的原因日后再更新.</li>\n</ul>\n"},{"title":"迁移完成","date":"2016-10-07T03:51:13.000Z","_content":"个人blog从WordPress迁到Hexo了\n头疼啊,为什么别人就能遇见讨人喜欢的背景图呢\n还有icon...\nhello,Hexo~","source":"_posts/迁移完成.md","raw":"---\ntitle: 迁移完成\ndate: 2016-10-07 11:51:13\ntags:\ncategories:\n\t纪念\n---\n个人blog从WordPress迁到Hexo了\n头疼啊,为什么别人就能遇见讨人喜欢的背景图呢\n还有icon...\nhello,Hexo~","slug":"迁移完成","published":1,"updated":"2018-10-31T09:05:30.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnwyh59u000xksk305b24fek","content":"<p>个人blog从WordPress迁到Hexo了<br>头疼啊,为什么别人就能遇见讨人喜欢的背景图呢<br>还有icon…<br>hello,Hexo~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>个人blog从WordPress迁到Hexo了<br>头疼啊,为什么别人就能遇见讨人喜欢的背景图呢<br>还有icon…<br>hello,Hexo~</p>\n"},{"title":"POST和GET","date":"2017-02-21T06:09:53.000Z","_content":"## 区别\n根源上来说,参看[RFC2616](https://tools.ietf.org/html/rfc2616#page-53)\n### GET\nThe GET method means retrieve whatever information (in the form of an\n   entity) is identified by the Request-URI. If the Request-URI refers\n   to a data-producing process, it is the produced data which shall be\n   returned as the entity in the response and not the source text of the\n   process, unless that text happens to be the output of the process.\n\n   The semantics of the GET method change to a \"conditional GET\" if the\n   request message includes an If-Modified-Since, If-Unmodified-Since,\n   If-Match, If-None-Match, or If-Range header field. A conditional GET\n   method requests that the entity be transferred only under the\n   circumstances described by the conditional header field(s). The\n   conditional GET method is intended to reduce unnecessary network\n   usage by allowing cached entities to be refreshed without requiring\n   multiple requests or transferring data already held by the client.\n\n   The semantics of the GET method change to a \"partial GET\" if the\n   request message includes a Range header field. A partial GET requests\n   that only part of the entity be transferred, as described in section\n   14.35. The partial GET method is intended to reduce unnecessary\n   network usage by allowing partially-retrieved entities to be\n   completed without transferring data already held by the client.\n\n   The response to a GET request is cacheable if and only if it meets\n   the requirements for HTTP caching described in section 13.\n\n   See section 15.1.3 for security considerations when used for forms.\n### POST\nThe POST method is used to request that the origin server accept the\n   entity enclosed in the request as a new subordinate of the resource\n   identified by the Request-URI in the Request-Line. POST is designed\n   to allow a uniform method to cover the following functions:\n\n      - Annotation of existing resources;\n\n      - Posting a message to a bulletin board, newsgroup, mailing list,\n        or similar group of articles;\n\n      - Providing a block of data, such as the result of submitting a\n        form, to a data-handling process;\n\n      - Extending a database through an append operation.\n\n   The actual function performed by the POST method is determined by the\n   server and is usually dependent on the Request-URI. The posted entity\n   is subordinate to that URI in the same way that a file is subordinate\n   to a directory containing it, a news article is subordinate to a\n   newsgroup to which it is posted, or a record is subordinate to a\n   database.\n\n   The action performed by the POST method might not result in a\n   resource that can be identified by a URI. In this case, either 200\n   (OK) or 204 (No Content) is the appropriate response status,\n   depending on whether or not the response includes an entity that\n   describes the result.\n\n   If a resource has been created on the origin server, the response\n   SHOULD be 201 (Created) and contain an entity which describes the\n   status of the request and refers to the new resource, and a Location\n   header (see section 14.30).\n\n   Responses to this method are not cacheable, unless the response\n   includes appropriate Cache-Control or Expires header fields. However,\n   the 303 (See Other) response can be used to direct the user agent to\n   retrieve a cacheable resource.\n\n   POST requests MUST obey the message transmission requirements set out\n   in section 8.2.\n\n   See section 15.1.3 for security considerations.\n\n可知,二者**最本质**的区别在于:\n    - GET 方法意思是获取被请求 URI（Request-URI）指定的信息（以实体的格式).\n    - POST 方法被用于请求源服务器接受请求中的实体作为请求资源的一个新的从属物.\n除此之外,二者**较为本质**的区别还有:\n    - GET幂等,POST不幂等.\n    - GET强制服务器支持,而POST在规范(HTTP/1.1)中为可选支持.\n    - GET请求的相应是可缓存的,POST 方法的响应是不可缓存的。除非响应里有合适的 Cache-Control 或者 Expires 头域。然而,303响应能被用户代理利用去获得可缓存的响应\n我们再去看一下目前充斥于搜索引擎搜索结果的所谓二者的区别:\n    - 后退/刷新时,get无害(相当于重新获取),post会重新提交(重新修改):基于二者**本质区别**\n    - GET 请求可被缓存,POST不可以:正确.\n    - GET 请求参数保留在浏览器历史记录中,而POST不可以:因为GET参数就在url中,显然.\n    - GET 请求可被收藏为书签,POST不可以:同上,显然.\n    - GET 请求不应在处理敏感数据时使用:显然.\n    - GET 请求有长度限制:错误,GET请求长度体现在url,而http相关规范**从来没有**规定过url的长度限制,所谓的限制只是**特定浏览器**的限制.多为2048B或者1024B\n    - GET 请求只应当用于取回数据\n    - GET编码类型限定为application/x-www-form-urlencoded,POST有多种类型(下面会总结一些常用的类型)\n    - GET只允许ASCII数据类型,POST无限制:大多数浏览器服务器如此实现\n    - GET方法产生一个TCP数据包；POST方法产生两个TCP数据包:同上,比如Firefox就不是这么玩的.\n    - 安全性,呵呵呵呵呵\n    - 可见性,同上.\n一言以蔽之,除了上述的**本质区别**,**较为本质的区别**,其他GET和POST的玩法都是浏览器,服务器的规定而已,我们可以给POST用url传参,也可以给GET加上报文体,毕竟HTTP规范只在语义上规定了二者嘛.\n## POST的content-type\n比较常见的\n- application/x-www-form-urlencoded 在报文体里以和GET相同的格式传输数据\n- application/json 消息主体是序列化的JSON字符串\n- multipart/form-data 传文件\n## 表单的content-type\n正常情况下,默认application/x-www-form-urlencoded,可换成multipart/form-data,具体参见[W3C相关资料](https://www.w3.org/TR/html401/cover.html#minitoc)\n\n部分信息为道听途说,未经验证,如有谬误,欢迎指正.\n\n\n\n","source":"_posts/POST和GET.md","raw":"---\ntitle: POST和GET\ndate: 2017-02-21 14:09:53\ntags:\n---\n## 区别\n根源上来说,参看[RFC2616](https://tools.ietf.org/html/rfc2616#page-53)\n### GET\nThe GET method means retrieve whatever information (in the form of an\n   entity) is identified by the Request-URI. If the Request-URI refers\n   to a data-producing process, it is the produced data which shall be\n   returned as the entity in the response and not the source text of the\n   process, unless that text happens to be the output of the process.\n\n   The semantics of the GET method change to a \"conditional GET\" if the\n   request message includes an If-Modified-Since, If-Unmodified-Since,\n   If-Match, If-None-Match, or If-Range header field. A conditional GET\n   method requests that the entity be transferred only under the\n   circumstances described by the conditional header field(s). The\n   conditional GET method is intended to reduce unnecessary network\n   usage by allowing cached entities to be refreshed without requiring\n   multiple requests or transferring data already held by the client.\n\n   The semantics of the GET method change to a \"partial GET\" if the\n   request message includes a Range header field. A partial GET requests\n   that only part of the entity be transferred, as described in section\n   14.35. The partial GET method is intended to reduce unnecessary\n   network usage by allowing partially-retrieved entities to be\n   completed without transferring data already held by the client.\n\n   The response to a GET request is cacheable if and only if it meets\n   the requirements for HTTP caching described in section 13.\n\n   See section 15.1.3 for security considerations when used for forms.\n### POST\nThe POST method is used to request that the origin server accept the\n   entity enclosed in the request as a new subordinate of the resource\n   identified by the Request-URI in the Request-Line. POST is designed\n   to allow a uniform method to cover the following functions:\n\n      - Annotation of existing resources;\n\n      - Posting a message to a bulletin board, newsgroup, mailing list,\n        or similar group of articles;\n\n      - Providing a block of data, such as the result of submitting a\n        form, to a data-handling process;\n\n      - Extending a database through an append operation.\n\n   The actual function performed by the POST method is determined by the\n   server and is usually dependent on the Request-URI. The posted entity\n   is subordinate to that URI in the same way that a file is subordinate\n   to a directory containing it, a news article is subordinate to a\n   newsgroup to which it is posted, or a record is subordinate to a\n   database.\n\n   The action performed by the POST method might not result in a\n   resource that can be identified by a URI. In this case, either 200\n   (OK) or 204 (No Content) is the appropriate response status,\n   depending on whether or not the response includes an entity that\n   describes the result.\n\n   If a resource has been created on the origin server, the response\n   SHOULD be 201 (Created) and contain an entity which describes the\n   status of the request and refers to the new resource, and a Location\n   header (see section 14.30).\n\n   Responses to this method are not cacheable, unless the response\n   includes appropriate Cache-Control or Expires header fields. However,\n   the 303 (See Other) response can be used to direct the user agent to\n   retrieve a cacheable resource.\n\n   POST requests MUST obey the message transmission requirements set out\n   in section 8.2.\n\n   See section 15.1.3 for security considerations.\n\n可知,二者**最本质**的区别在于:\n    - GET 方法意思是获取被请求 URI（Request-URI）指定的信息（以实体的格式).\n    - POST 方法被用于请求源服务器接受请求中的实体作为请求资源的一个新的从属物.\n除此之外,二者**较为本质**的区别还有:\n    - GET幂等,POST不幂等.\n    - GET强制服务器支持,而POST在规范(HTTP/1.1)中为可选支持.\n    - GET请求的相应是可缓存的,POST 方法的响应是不可缓存的。除非响应里有合适的 Cache-Control 或者 Expires 头域。然而,303响应能被用户代理利用去获得可缓存的响应\n我们再去看一下目前充斥于搜索引擎搜索结果的所谓二者的区别:\n    - 后退/刷新时,get无害(相当于重新获取),post会重新提交(重新修改):基于二者**本质区别**\n    - GET 请求可被缓存,POST不可以:正确.\n    - GET 请求参数保留在浏览器历史记录中,而POST不可以:因为GET参数就在url中,显然.\n    - GET 请求可被收藏为书签,POST不可以:同上,显然.\n    - GET 请求不应在处理敏感数据时使用:显然.\n    - GET 请求有长度限制:错误,GET请求长度体现在url,而http相关规范**从来没有**规定过url的长度限制,所谓的限制只是**特定浏览器**的限制.多为2048B或者1024B\n    - GET 请求只应当用于取回数据\n    - GET编码类型限定为application/x-www-form-urlencoded,POST有多种类型(下面会总结一些常用的类型)\n    - GET只允许ASCII数据类型,POST无限制:大多数浏览器服务器如此实现\n    - GET方法产生一个TCP数据包；POST方法产生两个TCP数据包:同上,比如Firefox就不是这么玩的.\n    - 安全性,呵呵呵呵呵\n    - 可见性,同上.\n一言以蔽之,除了上述的**本质区别**,**较为本质的区别**,其他GET和POST的玩法都是浏览器,服务器的规定而已,我们可以给POST用url传参,也可以给GET加上报文体,毕竟HTTP规范只在语义上规定了二者嘛.\n## POST的content-type\n比较常见的\n- application/x-www-form-urlencoded 在报文体里以和GET相同的格式传输数据\n- application/json 消息主体是序列化的JSON字符串\n- multipart/form-data 传文件\n## 表单的content-type\n正常情况下,默认application/x-www-form-urlencoded,可换成multipart/form-data,具体参见[W3C相关资料](https://www.w3.org/TR/html401/cover.html#minitoc)\n\n部分信息为道听途说,未经验证,如有谬误,欢迎指正.\n\n\n\n","slug":"POST和GET","published":1,"updated":"2018-10-31T09:05:30.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnwyh59v0010ksk3fm18hmw3","content":"<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><p>根源上来说,参看<a href=\"https://tools.ietf.org/html/rfc2616#page-53\" target=\"_blank\" rel=\"noopener\">RFC2616</a></p>\n<h3 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h3><p>The GET method means retrieve whatever information (in the form of an<br>   entity) is identified by the Request-URI. If the Request-URI refers<br>   to a data-producing process, it is the produced data which shall be<br>   returned as the entity in the response and not the source text of the<br>   process, unless that text happens to be the output of the process.</p>\n<p>   The semantics of the GET method change to a “conditional GET” if the<br>   request message includes an If-Modified-Since, If-Unmodified-Since,<br>   If-Match, If-None-Match, or If-Range header field. A conditional GET<br>   method requests that the entity be transferred only under the<br>   circumstances described by the conditional header field(s). The<br>   conditional GET method is intended to reduce unnecessary network<br>   usage by allowing cached entities to be refreshed without requiring<br>   multiple requests or transferring data already held by the client.</p>\n<p>   The semantics of the GET method change to a “partial GET” if the<br>   request message includes a Range header field. A partial GET requests<br>   that only part of the entity be transferred, as described in section<br>   14.35. The partial GET method is intended to reduce unnecessary<br>   network usage by allowing partially-retrieved entities to be<br>   completed without transferring data already held by the client.</p>\n<p>   The response to a GET request is cacheable if and only if it meets<br>   the requirements for HTTP caching described in section 13.</p>\n<p>   See section 15.1.3 for security considerations when used for forms.</p>\n<h3 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h3><p>The POST method is used to request that the origin server accept the<br>   entity enclosed in the request as a new subordinate of the resource<br>   identified by the Request-URI in the Request-Line. POST is designed<br>   to allow a uniform method to cover the following functions:</p>\n<pre><code>- Annotation of existing resources;\n\n- Posting a message to a bulletin board, newsgroup, mailing list,\n  or similar group of articles;\n\n- Providing a block of data, such as the result of submitting a\n  form, to a data-handling process;\n\n- Extending a database through an append operation.\n</code></pre><p>   The actual function performed by the POST method is determined by the<br>   server and is usually dependent on the Request-URI. The posted entity<br>   is subordinate to that URI in the same way that a file is subordinate<br>   to a directory containing it, a news article is subordinate to a<br>   newsgroup to which it is posted, or a record is subordinate to a<br>   database.</p>\n<p>   The action performed by the POST method might not result in a<br>   resource that can be identified by a URI. In this case, either 200<br>   (OK) or 204 (No Content) is the appropriate response status,<br>   depending on whether or not the response includes an entity that<br>   describes the result.</p>\n<p>   If a resource has been created on the origin server, the response<br>   SHOULD be 201 (Created) and contain an entity which describes the<br>   status of the request and refers to the new resource, and a Location<br>   header (see section 14.30).</p>\n<p>   Responses to this method are not cacheable, unless the response<br>   includes appropriate Cache-Control or Expires header fields. However,<br>   the 303 (See Other) response can be used to direct the user agent to<br>   retrieve a cacheable resource.</p>\n<p>   POST requests MUST obey the message transmission requirements set out<br>   in section 8.2.</p>\n<p>   See section 15.1.3 for security considerations.</p>\n<p>可知,二者<strong>最本质</strong>的区别在于:</p>\n<pre><code>- GET 方法意思是获取被请求 URI（Request-URI）指定的信息（以实体的格式).\n- POST 方法被用于请求源服务器接受请求中的实体作为请求资源的一个新的从属物.\n</code></pre><p>除此之外,二者<strong>较为本质</strong>的区别还有:</p>\n<pre><code>- GET幂等,POST不幂等.\n- GET强制服务器支持,而POST在规范(HTTP/1.1)中为可选支持.\n- GET请求的相应是可缓存的,POST 方法的响应是不可缓存的。除非响应里有合适的 Cache-Control 或者 Expires 头域。然而,303响应能被用户代理利用去获得可缓存的响应\n</code></pre><p>我们再去看一下目前充斥于搜索引擎搜索结果的所谓二者的区别:</p>\n<pre><code>- 后退/刷新时,get无害(相当于重新获取),post会重新提交(重新修改):基于二者**本质区别**\n- GET 请求可被缓存,POST不可以:正确.\n- GET 请求参数保留在浏览器历史记录中,而POST不可以:因为GET参数就在url中,显然.\n- GET 请求可被收藏为书签,POST不可以:同上,显然.\n- GET 请求不应在处理敏感数据时使用:显然.\n- GET 请求有长度限制:错误,GET请求长度体现在url,而http相关规范**从来没有**规定过url的长度限制,所谓的限制只是**特定浏览器**的限制.多为2048B或者1024B\n- GET 请求只应当用于取回数据\n- GET编码类型限定为application/x-www-form-urlencoded,POST有多种类型(下面会总结一些常用的类型)\n- GET只允许ASCII数据类型,POST无限制:大多数浏览器服务器如此实现\n- GET方法产生一个TCP数据包；POST方法产生两个TCP数据包:同上,比如Firefox就不是这么玩的.\n- 安全性,呵呵呵呵呵\n- 可见性,同上.\n</code></pre><p>一言以蔽之,除了上述的<strong>本质区别</strong>,<strong>较为本质的区别</strong>,其他GET和POST的玩法都是浏览器,服务器的规定而已,我们可以给POST用url传参,也可以给GET加上报文体,毕竟HTTP规范只在语义上规定了二者嘛.</p>\n<h2 id=\"POST的content-type\"><a href=\"#POST的content-type\" class=\"headerlink\" title=\"POST的content-type\"></a>POST的content-type</h2><p>比较常见的</p>\n<ul>\n<li>application/x-www-form-urlencoded 在报文体里以和GET相同的格式传输数据</li>\n<li>application/json 消息主体是序列化的JSON字符串</li>\n<li>multipart/form-data 传文件<h2 id=\"表单的content-type\"><a href=\"#表单的content-type\" class=\"headerlink\" title=\"表单的content-type\"></a>表单的content-type</h2>正常情况下,默认application/x-www-form-urlencoded,可换成multipart/form-data,具体参见<a href=\"https://www.w3.org/TR/html401/cover.html#minitoc\" target=\"_blank\" rel=\"noopener\">W3C相关资料</a></li>\n</ul>\n<p>部分信息为道听途说,未经验证,如有谬误,欢迎指正.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><p>根源上来说,参看<a href=\"https://tools.ietf.org/html/rfc2616#page-53\" target=\"_blank\" rel=\"noopener\">RFC2616</a></p>\n<h3 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h3><p>The GET method means retrieve whatever information (in the form of an<br>   entity) is identified by the Request-URI. If the Request-URI refers<br>   to a data-producing process, it is the produced data which shall be<br>   returned as the entity in the response and not the source text of the<br>   process, unless that text happens to be the output of the process.</p>\n<p>   The semantics of the GET method change to a “conditional GET” if the<br>   request message includes an If-Modified-Since, If-Unmodified-Since,<br>   If-Match, If-None-Match, or If-Range header field. A conditional GET<br>   method requests that the entity be transferred only under the<br>   circumstances described by the conditional header field(s). The<br>   conditional GET method is intended to reduce unnecessary network<br>   usage by allowing cached entities to be refreshed without requiring<br>   multiple requests or transferring data already held by the client.</p>\n<p>   The semantics of the GET method change to a “partial GET” if the<br>   request message includes a Range header field. A partial GET requests<br>   that only part of the entity be transferred, as described in section<br>   14.35. The partial GET method is intended to reduce unnecessary<br>   network usage by allowing partially-retrieved entities to be<br>   completed without transferring data already held by the client.</p>\n<p>   The response to a GET request is cacheable if and only if it meets<br>   the requirements for HTTP caching described in section 13.</p>\n<p>   See section 15.1.3 for security considerations when used for forms.</p>\n<h3 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h3><p>The POST method is used to request that the origin server accept the<br>   entity enclosed in the request as a new subordinate of the resource<br>   identified by the Request-URI in the Request-Line. POST is designed<br>   to allow a uniform method to cover the following functions:</p>\n<pre><code>- Annotation of existing resources;\n\n- Posting a message to a bulletin board, newsgroup, mailing list,\n  or similar group of articles;\n\n- Providing a block of data, such as the result of submitting a\n  form, to a data-handling process;\n\n- Extending a database through an append operation.\n</code></pre><p>   The actual function performed by the POST method is determined by the<br>   server and is usually dependent on the Request-URI. The posted entity<br>   is subordinate to that URI in the same way that a file is subordinate<br>   to a directory containing it, a news article is subordinate to a<br>   newsgroup to which it is posted, or a record is subordinate to a<br>   database.</p>\n<p>   The action performed by the POST method might not result in a<br>   resource that can be identified by a URI. In this case, either 200<br>   (OK) or 204 (No Content) is the appropriate response status,<br>   depending on whether or not the response includes an entity that<br>   describes the result.</p>\n<p>   If a resource has been created on the origin server, the response<br>   SHOULD be 201 (Created) and contain an entity which describes the<br>   status of the request and refers to the new resource, and a Location<br>   header (see section 14.30).</p>\n<p>   Responses to this method are not cacheable, unless the response<br>   includes appropriate Cache-Control or Expires header fields. However,<br>   the 303 (See Other) response can be used to direct the user agent to<br>   retrieve a cacheable resource.</p>\n<p>   POST requests MUST obey the message transmission requirements set out<br>   in section 8.2.</p>\n<p>   See section 15.1.3 for security considerations.</p>\n<p>可知,二者<strong>最本质</strong>的区别在于:</p>\n<pre><code>- GET 方法意思是获取被请求 URI（Request-URI）指定的信息（以实体的格式).\n- POST 方法被用于请求源服务器接受请求中的实体作为请求资源的一个新的从属物.\n</code></pre><p>除此之外,二者<strong>较为本质</strong>的区别还有:</p>\n<pre><code>- GET幂等,POST不幂等.\n- GET强制服务器支持,而POST在规范(HTTP/1.1)中为可选支持.\n- GET请求的相应是可缓存的,POST 方法的响应是不可缓存的。除非响应里有合适的 Cache-Control 或者 Expires 头域。然而,303响应能被用户代理利用去获得可缓存的响应\n</code></pre><p>我们再去看一下目前充斥于搜索引擎搜索结果的所谓二者的区别:</p>\n<pre><code>- 后退/刷新时,get无害(相当于重新获取),post会重新提交(重新修改):基于二者**本质区别**\n- GET 请求可被缓存,POST不可以:正确.\n- GET 请求参数保留在浏览器历史记录中,而POST不可以:因为GET参数就在url中,显然.\n- GET 请求可被收藏为书签,POST不可以:同上,显然.\n- GET 请求不应在处理敏感数据时使用:显然.\n- GET 请求有长度限制:错误,GET请求长度体现在url,而http相关规范**从来没有**规定过url的长度限制,所谓的限制只是**特定浏览器**的限制.多为2048B或者1024B\n- GET 请求只应当用于取回数据\n- GET编码类型限定为application/x-www-form-urlencoded,POST有多种类型(下面会总结一些常用的类型)\n- GET只允许ASCII数据类型,POST无限制:大多数浏览器服务器如此实现\n- GET方法产生一个TCP数据包；POST方法产生两个TCP数据包:同上,比如Firefox就不是这么玩的.\n- 安全性,呵呵呵呵呵\n- 可见性,同上.\n</code></pre><p>一言以蔽之,除了上述的<strong>本质区别</strong>,<strong>较为本质的区别</strong>,其他GET和POST的玩法都是浏览器,服务器的规定而已,我们可以给POST用url传参,也可以给GET加上报文体,毕竟HTTP规范只在语义上规定了二者嘛.</p>\n<h2 id=\"POST的content-type\"><a href=\"#POST的content-type\" class=\"headerlink\" title=\"POST的content-type\"></a>POST的content-type</h2><p>比较常见的</p>\n<ul>\n<li>application/x-www-form-urlencoded 在报文体里以和GET相同的格式传输数据</li>\n<li>application/json 消息主体是序列化的JSON字符串</li>\n<li>multipart/form-data 传文件<h2 id=\"表单的content-type\"><a href=\"#表单的content-type\" class=\"headerlink\" title=\"表单的content-type\"></a>表单的content-type</h2>正常情况下,默认application/x-www-form-urlencoded,可换成multipart/form-data,具体参见<a href=\"https://www.w3.org/TR/html401/cover.html#minitoc\" target=\"_blank\" rel=\"noopener\">W3C相关资料</a></li>\n</ul>\n<p>部分信息为道听途说,未经验证,如有谬误,欢迎指正.</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjnwyh5970004ksk3mvhr04u7","category_id":"cjnwyh59a0006ksk36s0zzpn2","_id":"cjnwyh59j000fksk30959g14m"},{"post_id":"cjnwyh59b0007ksk3gvoe6j5l","category_id":"cjnwyh59f000bksk3sar3qrdh","_id":"cjnwyh59n000kksk34hf4g4p6"},{"post_id":"cjnwyh59f000dksk329ltmjfz","category_id":"cjnwyh59k000hksk36jtgfa6r","_id":"cjnwyh59s000sksk3pk5z6vlx"},{"post_id":"cjnwyh59h000eksk34qno8zya","category_id":"cjnwyh59k000hksk36jtgfa6r","_id":"cjnwyh59v000yksk3sjat86qa"},{"post_id":"cjnwyh59u000xksk305b24fek","category_id":"cjnwyh59w0011ksk3wx74fi05","_id":"cjnwyh59x0017ksk3dzdats2s"}],"PostTag":[{"post_id":"cjnwyh58y0000ksk3x6as7l5l","tag_id":"cjnwyh5950003ksk3et5gnswu","_id":"cjnwyh59q000oksk3a7yasqih"},{"post_id":"cjnwyh58y0000ksk3x6as7l5l","tag_id":"cjnwyh59c0008ksk351ronfj0","_id":"cjnwyh59s000qksk36h1orh4q"},{"post_id":"cjnwyh58y0000ksk3x6as7l5l","tag_id":"cjnwyh59f000cksk3vw5gzeec","_id":"cjnwyh59t000uksk31usjjruk"},{"post_id":"cjnwyh58y0000ksk3x6as7l5l","tag_id":"cjnwyh59j000gksk3cq1mxzmk","_id":"cjnwyh59u000wksk3so13zi48"},{"post_id":"cjnwyh5930002ksk3xtgf31uv","tag_id":"cjnwyh59n000lksk3uq02deu3","_id":"cjnwyh59x0013ksk3i2pjytoq"},{"post_id":"cjnwyh5930002ksk3xtgf31uv","tag_id":"cjnwyh59t000tksk379qhuep3","_id":"cjnwyh59x0014ksk3cyazzzpc"},{"post_id":"cjnwyh5930002ksk3xtgf31uv","tag_id":"cjnwyh59v000zksk3l2gzb7jg","_id":"cjnwyh59x0016ksk3vgcf1qbw"},{"post_id":"cjnwyh5970004ksk3mvhr04u7","tag_id":"cjnwyh59x0012ksk350giubxa","_id":"cjnwyh59y0018ksk3fxiimvu8"},{"post_id":"cjnwyh5980005ksk3no87lmd1","tag_id":"cjnwyh59x0015ksk3unwolocs","_id":"cjnwyh5a1001cksk3qocatpfg"},{"post_id":"cjnwyh5980005ksk3no87lmd1","tag_id":"cjnwyh59y0019ksk3ikaggh3j","_id":"cjnwyh5a1001dksk3tg8q0bkj"},{"post_id":"cjnwyh5980005ksk3no87lmd1","tag_id":"cjnwyh5a0001aksk3om1lwcks","_id":"cjnwyh5a1001fksk3lexrsf6y"},{"post_id":"cjnwyh59b0007ksk3gvoe6j5l","tag_id":"cjnwyh5a0001bksk3wnul5nql","_id":"cjnwyh5a2001hksk3o7f3v9rx"},{"post_id":"cjnwyh59b0007ksk3gvoe6j5l","tag_id":"cjnwyh5a1001eksk34najomrz","_id":"cjnwyh5a2001iksk3rlyaova9"},{"post_id":"cjnwyh59e000aksk3es7ddx1u","tag_id":"cjnwyh5a1001gksk3y4iy76m3","_id":"cjnwyh5a4001pksk3xgv4og1s"},{"post_id":"cjnwyh59e000aksk3es7ddx1u","tag_id":"cjnwyh5a2001jksk3rhb7aod7","_id":"cjnwyh5a4001qksk33x4nzea4"},{"post_id":"cjnwyh59e000aksk3es7ddx1u","tag_id":"cjnwyh5a3001kksk3ovzvega9","_id":"cjnwyh5a4001sksk38rwp6ph0"},{"post_id":"cjnwyh59e000aksk3es7ddx1u","tag_id":"cjnwyh5a3001lksk3k4myffzt","_id":"cjnwyh5a4001tksk33w4ew2g1"},{"post_id":"cjnwyh59e000aksk3es7ddx1u","tag_id":"cjnwyh5a3001mksk3pyjcrehk","_id":"cjnwyh5a5001vksk3qizols1d"},{"post_id":"cjnwyh59e000aksk3es7ddx1u","tag_id":"cjnwyh5a3001nksk3slwjqg4d","_id":"cjnwyh5a5001wksk3fg6bpk0e"},{"post_id":"cjnwyh59f000dksk329ltmjfz","tag_id":"cjnwyh5a4001oksk3cwv7gn48","_id":"cjnwyh5a5001yksk35qvjhqcl"},{"post_id":"cjnwyh59f000dksk329ltmjfz","tag_id":"cjnwyh5a4001rksk37rxove0y","_id":"cjnwyh5a5001zksk35cka72b6"},{"post_id":"cjnwyh59h000eksk34qno8zya","tag_id":"cjnwyh5a4001uksk3jxcxfinp","_id":"cjnwyh5a50020ksk33yaht2a7"},{"post_id":"cjnwyh59m000jksk37zeara4b","tag_id":"cjnwyh5a5001xksk3t46ukvey","_id":"cjnwyh5a60024ksk3kb1nyuzt"},{"post_id":"cjnwyh59m000jksk37zeara4b","tag_id":"cjnwyh5a50021ksk39zi0m4p8","_id":"cjnwyh5a60025ksk3lt75tioc"},{"post_id":"cjnwyh59m000jksk37zeara4b","tag_id":"cjnwyh5a60022ksk3voo9826k","_id":"cjnwyh5a70027ksk3ylmo2vuz"},{"post_id":"cjnwyh59n000mksk32i7dt1p9","tag_id":"cjnwyh5a60023ksk3zda9ic4b","_id":"cjnwyh5a8002aksk3464af3hq"},{"post_id":"cjnwyh59n000mksk32i7dt1p9","tag_id":"cjnwyh5a60022ksk3voo9826k","_id":"cjnwyh5a8002bksk3jgc7lp88"},{"post_id":"cjnwyh59n000mksk32i7dt1p9","tag_id":"cjnwyh5a4001oksk3cwv7gn48","_id":"cjnwyh5a9002dksk3i0inoxbc"},{"post_id":"cjnwyh59q000pksk3hkrv426t","tag_id":"cjnwyh5a80029ksk3r1j073l5","_id":"cjnwyh5aa002gksk328xq6dll"},{"post_id":"cjnwyh59q000pksk3hkrv426t","tag_id":"cjnwyh5a60022ksk3voo9826k","_id":"cjnwyh5aa002hksk366rqveec"},{"post_id":"cjnwyh59q000pksk3hkrv426t","tag_id":"cjnwyh5a9002eksk3ahzo3cxi","_id":"cjnwyh5aa002jksk3y9j59n6m"},{"post_id":"cjnwyh59s000rksk3fgsy4gho","tag_id":"cjnwyh5a9002fksk3n8snk0dz","_id":"cjnwyh5ab002nksk3kaux0fkh"},{"post_id":"cjnwyh59s000rksk3fgsy4gho","tag_id":"cjnwyh5aa002iksk3lme8nu8i","_id":"cjnwyh5ab002oksk3edewnmum"},{"post_id":"cjnwyh59s000rksk3fgsy4gho","tag_id":"cjnwyh5aa002kksk3gkeuxff0","_id":"cjnwyh5ac002qksk393f50fow"},{"post_id":"cjnwyh59s000rksk3fgsy4gho","tag_id":"cjnwyh5ab002lksk3i8kd6e0z","_id":"cjnwyh5ac002rksk3w5mj6z7f"},{"post_id":"cjnwyh59t000vksk3si0n41pl","tag_id":"cjnwyh5ab002mksk3gwqghdt3","_id":"cjnwyh5ac002uksk3d7z7icnn"},{"post_id":"cjnwyh59t000vksk3si0n41pl","tag_id":"cjnwyh5ab002pksk33r6b8r3a","_id":"cjnwyh5ad002vksk36kbo6ogj"},{"post_id":"cjnwyh59t000vksk3si0n41pl","tag_id":"cjnwyh5ac002sksk3v379aima","_id":"cjnwyh5ad002wksk3hk73is3b"},{"post_id":"cjnwyh59t000vksk3si0n41pl","tag_id":"cjnwyh5ac002tksk3j5x4g4qp","_id":"cjnwyh5ad002xksk31737cpc6"}],"Tag":[{"name":"Chrome","_id":"cjnwyh5950003ksk3et5gnswu"},{"name":"DevTools","_id":"cjnwyh59c0008ksk351ronfj0"},{"name":"快捷键","_id":"cjnwyh59f000cksk3vw5gzeec"},{"name":"Mac","_id":"cjnwyh59j000gksk3cq1mxzmk"},{"name":"CSS","_id":"cjnwyh59n000lksk3uq02deu3"},{"name":"规范","_id":"cjnwyh59t000tksk379qhuep3"},{"name":"length","_id":"cjnwyh59v000zksk3l2gzb7jg"},{"name":"css","_id":"cjnwyh59x0012ksk350giubxa"},{"name":"HTML5","_id":"cjnwyh59x0015ksk3unwolocs"},{"name":"标签","_id":"cjnwyh59y0019ksk3ikaggh3j"},{"name":"语义化","_id":"cjnwyh5a0001aksk3om1lwcks"},{"name":"IE","_id":"cjnwyh5a0001bksk3wnul5nql"},{"name":"兼容性","_id":"cjnwyh5a1001eksk34najomrz"},{"name":"jQuery","_id":"cjnwyh5a1001gksk3y4iy76m3"},{"name":"位置","_id":"cjnwyh5a2001jksk3rhb7aod7"},{"name":"坐标","_id":"cjnwyh5a3001kksk3ovzvega9"},{"name":"viewport","_id":"cjnwyh5a3001lksk3k4myffzt"},{"name":"window","_id":"cjnwyh5a3001mksk3pyjcrehk"},{"name":"document","_id":"cjnwyh5a3001nksk3slwjqg4d"},{"name":"vue","_id":"cjnwyh5a4001oksk3cwv7gn48"},{"name":"文档","_id":"cjnwyh5a4001rksk37rxove0y"},{"name":"vue2.0","_id":"cjnwyh5a4001uksk3jxcxfinp"},{"name":"事件","_id":"cjnwyh5a5001xksk3t46ukvey"},{"name":"HTML","_id":"cjnwyh5a50021ksk39zi0m4p8"},{"name":"JavaScript","_id":"cjnwyh5a60022ksk3voo9826k"},{"name":"错误监控","_id":"cjnwyh5a60023ksk3zda9ic4b"},{"name":"你不知道的JavaScript","_id":"cjnwyh5a80029ksk3r1j073l5"},{"name":"读书笔记","_id":"cjnwyh5a9002eksk3ahzo3cxi"},{"name":"爬虫","_id":"cjnwyh5a9002fksk3n8snk0dz"},{"name":"Node.js","_id":"cjnwyh5aa002iksk3lme8nu8i"},{"name":"电子书","_id":"cjnwyh5aa002kksk3gkeuxff0"},{"name":"版权","_id":"cjnwyh5ab002lksk3i8kd6e0z"},{"name":"复盘","_id":"cjnwyh5ab002mksk3gwqghdt3"},{"name":"编译","_id":"cjnwyh5ab002pksk33r6b8r3a"},{"name":"node_modules","_id":"cjnwyh5ac002sksk3v379aima"},{"name":"bug","_id":"cjnwyh5ac002tksk3j5x4g4qp"}]}}