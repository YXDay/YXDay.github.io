<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="description" content="主要是前端的技术...也不排除...千万不要写..." />
  

  
  
  
  
  
  
  <title>橘子园</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="主要是前端的技术...也不排除...千万不要写...">
<meta property="og:type" content="website">
<meta property="og:title" content="橘子园">
<meta property="og:url" content="yxday.github.io/index.html">
<meta property="og:site_name" content="橘子园">
<meta property="og:description" content="主要是前端的技术...也不排除...千万不要写...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="橘子园">
<meta name="twitter:description" content="主要是前端的技术...也不排除...千万不要写...">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  <meta name="google-site-verification" content="PxYdO0Jmez3ae-gYahqeolRvGsm6KLNhVeImhgWRuxk" />
  <!-- baidu webmaster push -->
  <!-- <script src='//push.zhanzhang.baidu.com/push.js'></script> -->
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="橘子园" rel="home">橘子园</a>
      </h1>
      
        <h2 class="site-description">
          <a href="/" id="subtitle">种橘子的地方</a>
        </h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-前端错误监控" class="post-前端错误监控 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/10/31/前端错误监控/">前端错误监控</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="yxday.github.io/2018/10/31/前端错误监控/" data-id="cjnwyh59n000mksk32i7dt1p9" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="监听内容"><a href="#监听内容" class="headerlink" title="监听内容"></a>监听内容</h1><p>1 静态资源404<br>2 异步接口错误的上报<br>3 vue error错误上报<br>4 promise 捕获</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>vue error 监听<ul>
<li>vue捕获了 vue 运行中产生的错误，故无法直接使用全局错误监听的方式监听此类错误，需使用 vue 提供的errorHandler 接口来实现对错误的监听。</li>
</ul>
</li>
<li>js error及 静态资源错误<ul>
<li>均使用 addeventlistener 函数在 window 上添加 error 事件监听。</li>
<li>对于静态资源错误，不会冒泡，故上述监听函数应使用捕获模式。</li>
<li>静态资源的网络相关错误信息（如错误码）无法通过常规方式得到，故需在监听到静态资源错误的时候，对发生错误的链接发送一个 HEAD 的请求，以获取对应的网络相关错误信息。</li>
<li>HEAD方法跟GET方法相同，只不过服务器响应时不会返回消息体。一个HEAD请求的响应中，HTTP头中包含的元信息应该和一个GET请求的响应消息相同。这种方法可以用来获取请求中隐含的元信息，而不用传输实体本身。也经常用来测试超链接的有效性、可用性和最近的修改。</li>
</ul>
</li>
<li>异步接口错误<ul>
<li>重写XMLHttpRequest类的 send 和 open 方法，记录相关请求参数。</li>
<li>监听readystatechange事件，当 status 为表示错误的状态码（即大于等于400）时，上报错误</li>
</ul>
</li>
<li>promise 捕获<br> 　当我们希望在浏览器上捕获全局错误时会监听 window 对象的 error 事件，可是 error 事件只是捕获错误而已，对于 Promise 的 reject 未处理是不会触发的。如今在业务代码中我们越来越多地使用 Promise，导致很多被放在 Promise 中处理的逻辑错误仅仅是被 reject 没有触发 error。<br>　　通过 unhandledrejection 事件，我们就可以捕获未处理的 reject 。<br>　　因为 unhandledrejection 事件的接口中不包含 error 相关的信息，故我们无法获取堆栈信息，除非在 reject 的时候入参设置为一个 error 对象（如 <code>reject（new Error(&#39;error&#39;)</code>）</li>
</ol>
<h2 id="三种错误类型"><a href="#三种错误类型" class="headerlink" title="三种错误类型"></a>三种错误类型</h2><h3 id="JavaScript错误"><a href="#JavaScript错误" class="headerlink" title="JavaScript错误"></a>JavaScript错误</h3><ul>
<li><strong>即一切跟 JavaScript 相关的错误</strong>，包括<ul>
<li>JavaScript运行时错误</li>
<li>JavaScript语法错误</li>
<li>Promise reject 未处理</li>
<li>vue 运行时错误</li>
<li>用户自己抛出的错误。</li>
</ul>
</li>
<li>这些错误的共同特点是有堆栈信息，且堆栈信息有意义。<h3 id="静态资源错误"><a href="#静态资源错误" class="headerlink" title="静态资源错误"></a>静态资源错误</h3></li>
<li>即静态资源加载错误，如图片链接404等。</li>
<li>这些错误的共同特点是，有 DOM 信息。<h3 id="AJAX错误"><a href="#AJAX错误" class="headerlink" title="AJAX错误"></a>AJAX错误</h3></li>
<li>即 AJAX 请求时发生的错误，如服务器返回400，500等。</li>
<li>这些错误的共同特点不言而喻，都是 AJAX 请求。</li>
<li>后续考虑升级成对 HTTP 请求的监听</li>
</ul>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>使用lz-string</p>
<h3 id="压缩效率"><a href="#压缩效率" class="headerlink" title="压缩效率"></a>压缩效率</h3><p><strong>原大小的35.63%，减少了64.37%</strong></p>
<h4 id="压缩方式"><a href="#压缩方式" class="headerlink" title="压缩方式"></a>压缩方式</h4><p><strong>gzip</strong></p>
<h4 id="gzip与deflate对比"><a href="#gzip与deflate对比" class="headerlink" title="gzip与deflate对比"></a>gzip与deflate对比</h4><p>gzip的基础是DEFLATE，DEFLATE是LZ77与哈夫曼编码的一个组合体，二者区别主要有：</p>
<ol>
<li>两者都是使用Gzip压缩算法</li>
<li>deflate压缩速度略快，gzip压缩比略高。默认情况下，gzip会比deflate多压4%-6%</li>
<li>gzip对CPU占用要高一些，deflate是专门为保护性能的压缩模块，它仅需很小的资源来压缩文件<br>综上，我们更关注压缩比，故选择 gzip</li>
</ol>
<h2 id="错误合并逻辑"><a href="#错误合并逻辑" class="headerlink" title="错误合并逻辑"></a>错误合并逻辑</h2><h3 id="javascriptError"><a href="#javascriptError" class="headerlink" title="javascriptError"></a>javascriptError</h3><p>所在文件 类型 信息共5个因素一致即为同一错误</p>
<h3 id="httpError"><a href="#httpError" class="headerlink" title="httpError"></a>httpError</h3><p> url status statusText 3个因素一致即为同一错误</p>
<h3 id="resourceError"><a href="#resourceError" class="headerlink" title="resourceError"></a>resourceError</h3><p>url status statusText xpath 四个因素一致即为同一错误</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/10/31/前端错误监控/">
    <time datetime="2018-10-31T09:05:43.000Z" class="entry-date">
        2018-10-31
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/错误监控/">错误监控</a></li></ul>

    </footer>
</article>






  
    <article id="post-jQuery-offset" class="post-jQuery-offset post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/03/19/jQuery-offset/">jQuery offset()</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="yxday.github.io/2018/03/19/jQuery-offset/" data-id="cjnwyh59e000aksk3es7ddx1u" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>.offset()方法返回对应元素边框盒（包括外边距）<em>基于文档</em>的坐标值。<br>The .offset() method allows us to retrieve the current position of an element (specifically its border box, which excludes margins) <em>relative to the document</em>.</p>
<h2 id="核心源码"><a href="#核心源码" class="headerlink" title="核心源码"></a>核心源码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get document-relative position by adding viewport scroll to viewport-relative gBCR</span></span><br><span class="line">rect = elem.getBoundingClientRect();</span><br><span class="line">win = elem.ownerDocument.defaultView;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    top: rect.top + win.pageYOffset,</span><br><span class="line">    left: rect.left + win.pageXOffset</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>getBoundingClientRect返回的是<em>基于视口</em>的坐标。<br>如果不希望属性值随视口变化，那么只要给top、left属性值加上当前的滚动位置（通过window.scrollX和window.scrollY），这样就可以获取与当前的滚动位置无关的（<em>基于文档的</em>）常量值。</p>
<h2 id="视口，窗口，文档"><a href="#视口，窗口，文档" class="headerlink" title="视口，窗口，文档"></a>视口，窗口，文档</h2><ul>
<li>视口（viewport）：当前浏览器可视区域</li>
<li>窗口（window）：当前浏览器</li>
<li>文档（document）：当前文档</li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/03/19/jQuery-offset/">
    <time datetime="2018-03-19T06:58:37.000Z" class="entry-date">
        2018-03-19
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/document/">document</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/viewport/">viewport</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/window/">window</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/位置/">位置</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/坐标/">坐标</a></li></ul>

    </footer>
</article>






  
    <article id="post-Chrome-DevTools-重要快捷键-Mac" class="post-Chrome-DevTools-重要快捷键-Mac post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/03/15/Chrome-DevTools-重要快捷键-Mac/">Chrome DevTools 重要快捷键(Mac)</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="yxday.github.io/2018/03/15/Chrome-DevTools-重要快捷键-Mac/" data-id="cjnwyh58y0000ksk3x6as7l5l" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="Chrome-DevTools-重要快捷键-Mac"><a href="#Chrome-DevTools-重要快捷键-Mac" class="headerlink" title="Chrome DevTools 重要快捷键(Mac)"></a>Chrome DevTools 重要快捷键(Mac)</h1><h2 id="访问-DevTools"><a href="#访问-DevTools" class="headerlink" title="访问 DevTools"></a>访问 DevTools</h2><p>打开/切换检查元素模式和浏览器窗口  Cmd + Shift + C<br>打开 Developer Tools 并聚焦到控制台  Cmd + Opt + J</p>
<h2 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h2><p>显示设置  ?<br>上/下一个面板  Cmd + [/]<br>更改停靠位置  Cmd + Shift + D<br>Device Mode  Cmd + Shift + M<br>切换控制台 ESC<br>在所有源中搜索文本 Cmd + Opt + F<br>按文件名搜索（除了在 Timeline 上）  Cmd + O、Cmd + P</p>
<h2 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h2><p>展开/折叠节点及其所有子节点  Opt + 点击箭头图标<br>隐藏元素  H<br>切换为以 HTML 形式编辑  F2</p>
<h2 id="style"><a href="#style" class="headerlink" title="style"></a>style</h2><p>转到源中样式规则属性声明行  Cmd + 点击属性<br>在颜色定义值之间循环  Shift + 点击颜色选取器框<br>编辑下一个/上一个属性  Tab、Shift + Tab<br>以 10 为增量增大/减小值  Shift + Up、Shift + Down      PgUp、PgDown<br>以 100 为增量增大/减小值  Shift + PgUp、Shift + PgDown<br>以 0.1 为增量增大/减小值  Opt + 向上键、Opt + 向下键</p>
<h2 id="Sources"><a href="#Sources" class="headerlink" title="Sources"></a>Sources</h2><p>暂停/继续脚本执行      F8、Cmd + \<br>越过下一个函数调用  F10、Cmd + ‘<br>进入下一个函数调用  F11、Cmd + ;<br>跳出当前函数  Shift + F11、Cmd + Shift + ;<br>转到行  Ctrl + G<br>转到成员  Cmd + Shift + O</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/03/15/Chrome-DevTools-重要快捷键-Mac/">
    <time datetime="2018-03-15T06:17:01.000Z" class="entry-date">
        2018-03-15
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chrome/">Chrome</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DevTools/">DevTools</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mac/">Mac</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/快捷键/">快捷键</a></li></ul>

    </footer>
</article>






  
    <article id="post-复盘-fix不同node-modules引起的bug" class="post-复盘-fix不同node-modules引起的bug post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/03/15/复盘-fix不同node-modules引起的bug/">复盘-fix不同node_modules引起的bug</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="yxday.github.io/2018/03/15/复盘-fix不同node-modules引起的bug/" data-id="cjnwyh59t000vksk3si0n41pl" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="复盘-fix不同node-modules引起的bug"><a href="#复盘-fix不同node-modules引起的bug" class="headerlink" title="复盘-fix不同node_modules引起的bug"></a>复盘-fix不同node_modules引起的bug</h1><p>一份代码,线上的node_modules包是已有的,线下的node_modules包是我近期通过package.json自行yarn得来的.<br>当我把线下的node_modules包替换到线上时,线上报错,此时线下正常.<br>顺着错误信息一番debug,乱七八糟的代码使人眼晕,也查不出什么所以然.<br>此时冷静分析一下:同一份代码,线下正常,线上出错,二者有何区别?</p>
<ul>
<li>环境</li>
<li>构建方式<br>环境不去说他,小概率事件,构建方式有何不同呢,线下是develop构建,而线上是deploy,<br>二者的差别是,deploy的gulp流程多了rev,compress两个步骤,分而治之,证明是compress出了问题.<br>compress中的流程继续分而治之,是gulp-uglify这个包除了问题,对比一下,果然,旧的node_modules里gulp-uglify版本为2.0.0,新的为2.1.2,替换之,遂解决.<br>具体的原因日后再更新.</li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/03/15/复盘-fix不同node-modules引起的bug/">
    <time datetime="2018-03-15T06:16:04.000Z" class="entry-date">
        2018-03-15
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/bug/">bug</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node-modules/">node_modules</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/复盘/">复盘</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编译/">编译</a></li></ul>

    </footer>
</article>






  
    <article id="post-事件辨析" class="post-事件辨析 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/03/15/事件辨析/">事件辨析</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="yxday.github.io/2018/03/15/事件辨析/" data-id="cjnwyh59m000jksk37zeara4b" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h2><p>即通过与事件处理程序同名的HTML特性来实现.<br><code>&lt;input type=&quot;button&quot; onclick=&quot;alert(&#39;HTML&#39;)&quot;&gt;</code></p>
<ul>
<li>有权访问全局作用域中任意代码.</li>
<li>this值为事件的目标元素.</li>
<li>作用域扩展至document以及本元素本身,即相当于<code>with(this)</code>.</li>
<li>如果当前元素是一个表单输入元素,作用域扩展至整个表单元素,即相当于<code>with(this.form)</code>.</li>
<li>生成event对象,不必自己定义,亦不必从函数参数列表中获取.</li>
<li>存在时差问题,当HTML加载时,对应的JavaScript可能没有加载.</li>
<li>前述提到的作用域扩展在浏览器间行为并不一致.</li>
<li>可以通过设置当前元素DOM的对应事件处理属性为null的方式销毁事件.</li>
<li>显然应该在事件到达元素本身的时候处理.<h2 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h2>DOM0指第四代浏览器(IE4.0, Netscape4.0)最初支持的DOM规则,并不是事实存在的标准.<br>将一个函数赋值给一个事件处理程序属性,首先必须取得一个要操作对象的引用.<br><code>let btn = document.getElementById(&#39;btn&#39;);
btn.onclick = () =&gt; {
  alert(&#39;DOM0&#39;);
}</code></li>
<li>简单,跨浏览器兼容.</li>
<li>this引用当前元素.</li>
<li>在冒泡阶段被处理</li>
<li>销毁时设置对应属性为null <code>btn.onclick = null;</code><h2 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h2>addEventListener removeEventListener<br>接受三个参数,要处理的事件名,事件处理函数,布尔值(true,捕获阶段处理事件;false,冒泡阶段处理事件)</li>
<li>this引用当前元素</li>
<li>按顺序添加的事件按顺序执行</li>
<li>addEventListener添加的事件只能由removeEventListener移除,移除时需参数相同,这意味着匿名事件处理函数将无法移除.</li>
<li>捕获浏览器兼容性较差</li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/03/15/事件辨析/">
    <time datetime="2018-03-15T06:14:38.000Z" class="entry-date">
        2018-03-15
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/">HTML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/事件/">事件</a></li></ul>

    </footer>
</article>






  
    <article id="post-《你不知道的JavaScript》-上卷-读书笔记" class="post-《你不知道的JavaScript》-上卷-读书笔记 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/03/15/《你不知道的JavaScript》-上卷-读书笔记/">《你不知道的JavaScript》(上卷)读书笔记</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="yxday.github.io/2018/03/15/《你不知道的JavaScript》-上卷-读书笔记/" data-id="cjnwyh59q000pksk3hkrv426t" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="《你不知道的JavaScript》-上卷-读书笔记"><a href="#《你不知道的JavaScript》-上卷-读书笔记" class="headerlink" title="《你不知道的JavaScript》(上卷)读书笔记"></a>《你不知道的JavaScript》(上卷)读书笔记</h1><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><p>事实上,JavaScript是一门编译语言,但与传统的编译语言不同,他不是提前编译的,编译结果也不能在分布式系统中进行移植.</p>
<p>JavaScript引擎进行编译的步骤与传统语言非常相似,包括分词/词法分析,解析/语法分析,代码生成.</p>
<p>比起那些编译过程只有三个步骤的语言的编译器,JavaScript在语法分析和代码生成阶段有特定的步骤对运行性能进行优化,包括对冗余元素进行优化等</p>
<h3 id="LHS与RHS"><a href="#LHS与RHS" class="headerlink" title="LHS与RHS"></a>LHS与RHS</h3><ul>
<li>LHS:左值查询,试图找到变量的容器本身,从而可以对其赋值.</li>
<li>RHS:右值查询,与简单地查找某个变量的值别无二致.</li>
<li>从概念上讲,LHS查找赋值的目标,RHS查找赋值的源头.<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3>是定义在词法阶段的作用域,换句话说,是由你在写代码时将变量和块作用域写在哪里决定的,区别于动态作用域.<h4 id="欺骗词法作用域"><a href="#欺骗词法作用域" class="headerlink" title="欺骗词法作用域"></a>欺骗词法作用域</h4><h5 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h5></li>
<li>接受一个字符串为参数,并将其中的内容视为好像在书写时就存在于程序中的这个位置的代码.</li>
<li>严格模式下,eval有自己的词法作用域.</li>
<li>JavaScript中还有一些类似的功能效果,例如setTimeout以及setInterval第一个参数(本质上还是调用了eval),以及new Function的最后一个参数.<h5 id="with"><a href="#with" class="headerlink" title="with"></a>with</h5></li>
<li>尽管with块可以将一个对象处理为词法作用域,但是这个块内部正常的var声明比并不会被限制在这个块的作用域中,而是被添加到with所处的函数作用域中.</li>
<li>严格模式下被禁用了.<h5 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h5>编译阶段的很多优化没法做了.<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><h4 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h4>区分函数声明和表达式最简单的方法是看function关键字出现在生命中的位置。如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。<h4 id="匿名与具名"><a href="#匿名与具名" class="headerlink" title="匿名与具名"></a>匿名与具名</h4>始终给函数表达式命名是一个最佳实践。<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2></li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/03/15/《你不知道的JavaScript》-上卷-读书笔记/">
    <time datetime="2018-03-15T06:12:32.000Z" class="entry-date">
        2018-03-15
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/你不知道的JavaScript/">你不知道的JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>

    </footer>
</article>






  
    <article id="post-CSS-px" class="post-CSS-px post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/03/03/CSS-px/">CSS px</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="yxday.github.io/2017/03/03/CSS-px/" data-id="cjnwyh5930002ksk3xtgf31uv" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>px在CSS中指CSS像素,是相对于<strong>设备像素</strong>的<strong>相对值</strong>.<br>在W3C的<a href="https://www.w3.org/Style/Examples/007/units.en.html" target="_blank" rel="noopener">Web Style Sheets CSS tips &amp; tricks</a>中提到</p>
<blockquote>
<p>In fact, CSS requires that 1px must be exactly 1/96th of an inch in all printed output.</p>
</blockquote>
<p>所以这就很明白了.<br>比如iPhone 5使用的是Retina视网膜屏幕，使用2px x 2px的 device pixel 代表 1px x 1px 的 css pixel，所以设备像素数为640 x 1136px，而CSS逻辑像素数为320 x 568px。<br>需要用的时候,注意换算<strong>像素</strong>比就是了.</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/03/03/CSS-px/">
    <time datetime="2017-03-03T04:52:06.000Z" class="entry-date">
        2017-03-03
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/length/">length</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/规范/">规范</a></li></ul>

    </footer>
</article>






  
    <article id="post-POST和GET" class="post-POST和GET post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/02/21/POST和GET/">POST和GET</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="yxday.github.io/2017/02/21/POST和GET/" data-id="cjnwyh59v0010ksk3fm18hmw3" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>根源上来说,参看<a href="https://tools.ietf.org/html/rfc2616#page-53" target="_blank" rel="noopener">RFC2616</a></p>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>The GET method means retrieve whatever information (in the form of an<br>   entity) is identified by the Request-URI. If the Request-URI refers<br>   to a data-producing process, it is the produced data which shall be<br>   returned as the entity in the response and not the source text of the<br>   process, unless that text happens to be the output of the process.</p>
<p>   The semantics of the GET method change to a “conditional GET” if the<br>   request message includes an If-Modified-Since, If-Unmodified-Since,<br>   If-Match, If-None-Match, or If-Range header field. A conditional GET<br>   method requests that the entity be transferred only under the<br>   circumstances described by the conditional header field(s). The<br>   conditional GET method is intended to reduce unnecessary network<br>   usage by allowing cached entities to be refreshed without requiring<br>   multiple requests or transferring data already held by the client.</p>
<p>   The semantics of the GET method change to a “partial GET” if the<br>   request message includes a Range header field. A partial GET requests<br>   that only part of the entity be transferred, as described in section<br>   14.35. The partial GET method is intended to reduce unnecessary<br>   network usage by allowing partially-retrieved entities to be<br>   completed without transferring data already held by the client.</p>
<p>   The response to a GET request is cacheable if and only if it meets<br>   the requirements for HTTP caching described in section 13.</p>
<p>   See section 15.1.3 for security considerations when used for forms.</p>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>The POST method is used to request that the origin server accept the<br>   entity enclosed in the request as a new subordinate of the resource<br>   identified by the Request-URI in the Request-Line. POST is designed<br>   to allow a uniform method to cover the following functions:</p>
<pre><code>- Annotation of existing resources;

- Posting a message to a bulletin board, newsgroup, mailing list,
  or similar group of articles;

- Providing a block of data, such as the result of submitting a
  form, to a data-handling process;

- Extending a database through an append operation.
</code></pre><p>   The actual function performed by the POST method is determined by the<br>   server and is usually dependent on the Request-URI. The posted entity<br>   is subordinate to that URI in the same way that a file is subordinate<br>   to a directory containing it, a news article is subordinate to a<br>   newsgroup to which it is posted, or a record is subordinate to a<br>   database.</p>
<p>   The action performed by the POST method might not result in a<br>   resource that can be identified by a URI. In this case, either 200<br>   (OK) or 204 (No Content) is the appropriate response status,<br>   depending on whether or not the response includes an entity that<br>   describes the result.</p>
<p>   If a resource has been created on the origin server, the response<br>   SHOULD be 201 (Created) and contain an entity which describes the<br>   status of the request and refers to the new resource, and a Location<br>   header (see section 14.30).</p>
<p>   Responses to this method are not cacheable, unless the response<br>   includes appropriate Cache-Control or Expires header fields. However,<br>   the 303 (See Other) response can be used to direct the user agent to<br>   retrieve a cacheable resource.</p>
<p>   POST requests MUST obey the message transmission requirements set out<br>   in section 8.2.</p>
<p>   See section 15.1.3 for security considerations.</p>
<p>可知,二者<strong>最本质</strong>的区别在于:</p>
<pre><code>- GET 方法意思是获取被请求 URI（Request-URI）指定的信息（以实体的格式).
- POST 方法被用于请求源服务器接受请求中的实体作为请求资源的一个新的从属物.
</code></pre><p>除此之外,二者<strong>较为本质</strong>的区别还有:</p>
<pre><code>- GET幂等,POST不幂等.
- GET强制服务器支持,而POST在规范(HTTP/1.1)中为可选支持.
- GET请求的相应是可缓存的,POST 方法的响应是不可缓存的。除非响应里有合适的 Cache-Control 或者 Expires 头域。然而,303响应能被用户代理利用去获得可缓存的响应
</code></pre><p>我们再去看一下目前充斥于搜索引擎搜索结果的所谓二者的区别:</p>
<pre><code>- 后退/刷新时,get无害(相当于重新获取),post会重新提交(重新修改):基于二者**本质区别**
- GET 请求可被缓存,POST不可以:正确.
- GET 请求参数保留在浏览器历史记录中,而POST不可以:因为GET参数就在url中,显然.
- GET 请求可被收藏为书签,POST不可以:同上,显然.
- GET 请求不应在处理敏感数据时使用:显然.
- GET 请求有长度限制:错误,GET请求长度体现在url,而http相关规范**从来没有**规定过url的长度限制,所谓的限制只是**特定浏览器**的限制.多为2048B或者1024B
- GET 请求只应当用于取回数据
- GET编码类型限定为application/x-www-form-urlencoded,POST有多种类型(下面会总结一些常用的类型)
- GET只允许ASCII数据类型,POST无限制:大多数浏览器服务器如此实现
- GET方法产生一个TCP数据包；POST方法产生两个TCP数据包:同上,比如Firefox就不是这么玩的.
- 安全性,呵呵呵呵呵
- 可见性,同上.
</code></pre><p>一言以蔽之,除了上述的<strong>本质区别</strong>,<strong>较为本质的区别</strong>,其他GET和POST的玩法都是浏览器,服务器的规定而已,我们可以给POST用url传参,也可以给GET加上报文体,毕竟HTTP规范只在语义上规定了二者嘛.</p>
<h2 id="POST的content-type"><a href="#POST的content-type" class="headerlink" title="POST的content-type"></a>POST的content-type</h2><p>比较常见的</p>
<ul>
<li>application/x-www-form-urlencoded 在报文体里以和GET相同的格式传输数据</li>
<li>application/json 消息主体是序列化的JSON字符串</li>
<li>multipart/form-data 传文件<h2 id="表单的content-type"><a href="#表单的content-type" class="headerlink" title="表单的content-type"></a>表单的content-type</h2>正常情况下,默认application/x-www-form-urlencoded,可换成multipart/form-data,具体参见<a href="https://www.w3.org/TR/html401/cover.html#minitoc" target="_blank" rel="noopener">W3C相关资料</a></li>
</ul>
<p>部分信息为道听途说,未经验证,如有谬误,欢迎指正.</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/02/21/POST和GET/">
    <time datetime="2017-02-21T06:09:53.000Z" class="entry-date">
        2017-02-21
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-z-index要点" class="post-z-index要点 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/02/07/z-index要点/">z-index要点</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="yxday.github.io/2017/02/07/z-index要点/" data-id="cjnwyh59k000iksk34br3a57t" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>可以理解为”<em>版本号</em>“,即父元素为主版本,子元素为次要版本,由此来确立层叠顺序.</p>
<h2 id="父子"><a href="#父子" class="headerlink" title="父子"></a>父子</h2><p>父子元素下,<em>只要父元素设置了z-index值,无论子元素如何设置,其都在其父元素之上显示</em>,但是,如果父元素没有设置,或设置为默认值,当子组件设置z-index为负值时,子组件会放置于父组件之下.</p>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>z-index的默认值auto的意思为,不新建堆叠上下文,元素所在的堆叠上下文和其父元素相同.</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>基于以上规则,子元素作为次要”版本号”无法堆叠在其父版本的兄弟版本上时,解决思路有可以通过移除不同级别的菜单之间的重叠，或者使用ID选择器指定独立的（不同的）z-index值，或者减少HTML的层级。</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/02/07/z-index要点/">
    <time datetime="2017-02-07T11:25:06.000Z" class="entry-date">
        2017-02-07
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-span换行" class="post-span换行 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2017/01/27/span换行/">行内元素完整换行</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="yxday.github.io/2017/01/27/span换行/" data-id="cjnwyh59c0009ksk3t250cdkr" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>有这样一个需求,各个标签用行内元素(例如span)包裹(这样做往往是考虑到HTML语义),当容器宽度不足时,<em>完整换行</em>,即当行内剩余空间不足展示一个标签时,换行,而非标签内分断.<br>稍有常识的人一定知道,直接用span是不行的.<br>解决的方案当然也是十分简单,设置这些span的display属性为inline-block就可以了.<br>值得吐槽的是,chrome显示的行内元素的padding区域在出现换行的时候,会在每一行都显示,这样就会出现除最后一行外,其他行的内容会在”padding区域”(实际上并不是)显示,可能会对一些新手造成困扰.<br>Firefox显示正常.</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/01/27/span换行/">
    <time datetime="2017-01-27T03:32:26.000Z" class="entry-date">
        2017-01-27
    </time>
</a>
    
    
    </footer>
</article>






  
  
    <nav id="pagination">
      <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
      </nav>
    </nav>
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search">
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="yxday.github.io"></form>
</aside>
  
    <aside class="widget">
    <h3 class="widget-title">关于我</h3>
    <div class="widget-content">
      <p>邺则邺城水漳水，出没岂随人眼底</p>
      <p>邮箱：thufelixc(at)gmail.com</p>
      <p>微信：dyx278923692</p>
      <p>QQ: 278923692</p>
    </div>
</aside>
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2018/10/31/前端错误监控/">前端错误监控</a>
          </li>
        
          <li>
            <a href="/2018/03/19/jQuery-offset/">jQuery offset()</a>
          </li>
        
          <li>
            <a href="/2018/03/15/Chrome-DevTools-重要快捷键-Mac/">Chrome DevTools 重要快捷键(Mac)</a>
          </li>
        
          <li>
            <a href="/2018/03/15/复盘-fix不同node-modules引起的bug/">复盘-fix不同node_modules引起的bug</a>
          </li>
        
          <li>
            <a href="/2018/03/15/事件辨析/">事件辨析</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-content tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Chrome/" style="font-size: 10px;">Chrome</a> <a href="/tags/DevTools/" style="font-size: 10px;">DevTools</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/IE/" style="font-size: 10px;">IE</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/bug/" style="font-size: 10px;">bug</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/document/" style="font-size: 10px;">document</a> <a href="/tags/jQuery/" style="font-size: 10px;">jQuery</a> <a href="/tags/length/" style="font-size: 10px;">length</a> <a href="/tags/node-modules/" style="font-size: 10px;">node_modules</a> <a href="/tags/viewport/" style="font-size: 10px;">viewport</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/vue2-0/" style="font-size: 10px;">vue2.0</a> <a href="/tags/window/" style="font-size: 10px;">window</a> <a href="/tags/事件/" style="font-size: 10px;">事件</a> <a href="/tags/位置/" style="font-size: 10px;">位置</a> <a href="/tags/你不知道的JavaScript/" style="font-size: 10px;">你不知道的JavaScript</a> <a href="/tags/兼容性/" style="font-size: 10px;">兼容性</a> <a href="/tags/坐标/" style="font-size: 10px;">坐标</a> <a href="/tags/复盘/" style="font-size: 10px;">复盘</a> <a href="/tags/快捷键/" style="font-size: 10px;">快捷键</a> <a href="/tags/文档/" style="font-size: 10px;">文档</a> <a href="/tags/标签/" style="font-size: 10px;">标签</a> <a href="/tags/爬虫/" style="font-size: 10px;">爬虫</a> <a href="/tags/版权/" style="font-size: 10px;">版权</a> <a href="/tags/电子书/" style="font-size: 10px;">电子书</a> <a href="/tags/编译/" style="font-size: 10px;">编译</a> <a href="/tags/规范/" style="font-size: 10px;">规范</a> <a href="/tags/语义化/" style="font-size: 10px;">语义化</a> <a href="/tags/读书笔记/" style="font-size: 10px;">读书笔记</a> <a href="/tags/错误监控/" style="font-size: 10px;">错误监控</a>
    </div>
  </aside>

  
    <aside class="widget">
    <h3 class="widget-title"></h3>
    <div class="widget-content">
    <script>
	var _hmt = _hmt || [];
	(function() {
  		var hm = document.createElement("script");
  		hm.src = "https://hm.baidu.com/hm.js?c275e29e124b51a2fd933e39ddb615a1";
  		var s = document.getElementsByTagName("script")[0];
  		s.parentNode.insertBefore(hm, s);
	})();
	</script>
    </div>
</aside>

  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2018 thu
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>